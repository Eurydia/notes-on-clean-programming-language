{"/":{"title":"Cleanpedia","content":"\n## Introduction\n\nThe motivation of this reference is to create an accessible, concise, and clear documentation for those who are seeking to learn CLEAN.\n\nThe same information can be found on:\n\n- [Cloogle](https://cloogle.org/) which is the language’s search engine, and\n- [language report](https://cloogle.org/doc/) which describes the syntax and BNF of Clean.\n\nIf you notice any mistake or have suggestions for improvements, please feel free to contact me through the following channels:\n\n- Email: [b9xp3x@inf.elte.hu](mailto:b9xp3x@inf.elte.hu)\n- Instagram: [@\\_kornthana](https://www.instagram.com/_kornthana/)\n- Telegram channel: [https://t.me/+El6CtwOD8KxhYmU9](https://t.me/+El6CtwOD8KxhYmU9)\n\n## Functions\n\n### Defining A Function\n\n**Implementation**\n\nA control function implementation may be written as follows:\n\n```\n// Language: Clean\n\nfnName param = body\n```\n\nA function type can be placed before an implementation.\nThe topics of typing functions are discussed in more details in later parts of this chapter.\n\n```\n// Language: Clean\n\nfnName :: T      -\u003e K\nfnName    param  =  body\n```\n\nParameters of a function are space separated.\n\n```\n// Language: Clean\n\nfnName :: T      K      -\u003e V\nfnName    paramA paramB =  body\n```\n\nOn global scope, $\\implies$ may be used to separate function parameters from function body.\n\n```\n// Langauge: Clean\n// In global scope\n\nfn :: T      K      -\u003e V\nfn    paramA paramB =\u003e body\n```\n\nA simple function can be defined as follows.\n\n```\n// Language: Clean\n\nincrement :: Int -\u003e Int\nincrement    n   =  n + 1\n```\n\nIt is allowed for a function to be implemented multiple times, but implementations must be grouped together.\n\n```\n// Language: Clean\n\nisNice :: Int -\u003e Bool\nisNice    8   =\u003e True\nisNice    _   =\u003e False\n```\n\nAs such, the following is not allowed.\n\n```\n// Language: Clean\n\nisNice :: Int -\u003e Bool\nisNice    8   =\u003e True\n\n6 + 2\n\nisNice    _   =\u003e False\n```\n\nImplementations are tried in textual order, and an implementation is chosen, if the arguments of a function call matched with the parameters.\n\n```\n// Language: Clean\n\nisNice 9  // False\n```\n\nThe argument ($9$) does not match with the parameter ($8$) of the first implementation.\nTherefore, it is not evaluated.\n\nThe argument matches with the parameter of the second implementation.\nThus, the second implementation is evaluated.\n\nSimilarly, if it is invoked with $8$, the first implementation is evaluated, and the second is never tried.\n\n```\n// Language: Clean\n\nfib 8  // True\n```\n\nFollowing this logic, if order of implementation is changed, then the function would behave in unintended ways.\n\n```\n// Language: Clean\n\nisNice :: Int -\u003e Int\nisNice    _   =\u003e False\nisNice    8   =\u003e True\n```\n\nWildcards ($\\_$) matches with any argument of a function call.\nTherefore, the second implementation is never reached.\n\nIt is important to recognize that, this parameter-matching behavior is not the same as performing equality checks.\n\n**Guarded bodies**\n\nA guarded body can be introduce to an implementation of a function.\nIt allows an implementation to have multiple function bodies, instead of just one.\n\nIt has the following syntax.\n\n```\n// Language: Clean\n\n[fnName] [fnParams]\n| [guardA]         = [bodyA]\n| [guardB]         = [bodyB]\n| [guardC]         = [bodyC]\n```\n\nAdditionally, guarded bodies can be nested.\n\n```\n// Language: Clean\n\n[fnName] [fnParams]\n| [guardA]\n    | [guardAA]    = [bodyAA]\n    | [guardAB]    = [bodyAB]\n| [guardB]         = [bodyB]\n| [guardC]         = [bodyC]\n```\n\nA guard is a Boolean expression.\n\n```\n// Language: Clean\n\nsignum :: Int -\u003e Int\nsignum    0   =  0\nsignum    n\n| n \u003e 0       =  1\n| n \u003c 0       = -1\n```\n\nGuards are tried in textual order, but only after their implementation is chosen.\n\nFor example:\n\nWhen called with $0$, the first implementation is tried.\n\n```\n// Language: Clean\n\nsignum 0\n```\n\nThe argument and parameter match.\nThus, the body of the first implementation is evaluated.\n\nIn this call, none of the guards were tried, since the implementation that they belong to was not chosen.\n\nInstead, if it is called with a non-zero integer, the first implementation will fail to match.\n\n```\n// Language: Clean\n\nsignum -9\n```\n\nIn this case, the first guard ($n\\gt{0}$) is tried.\nIt evaluates to $\\textbf{False}$.\nIts body is not evaluated.\n\nThe second guard is tried ($n\\lt{0}$).\nIt evaluates to $\\textbf{True}$.\nTherefore, the body of the second guard is evaluated.\n\nAlternatively, $\\textbf{otherwise}$ keyword can be used instead of an expression.\nIts value is always $\\textbf{True}$.\n\n```\n// Language: Clean\n\nsignum :: Int -\u003e Int\nsignum    0   =  0\nsignum    n\n| n \u003e 0       =  1\n| otherwise   = -1\n```\n\nAs such, order of the guarded bodies also matters.\n\n```\n// Language: Clean\n\n\nsignum :: Int -\u003e Int\nsignum    0   =  0\nsignum    n\n| otherwise   = -1\n| n \u003e 0       =  1\n```\n\n**Partial functions**\n\nIt is important to recognize that, an implementation with guarded bodies can be partial.\n\nSuch implementations will result in a run-time error when invoked outside its domain.\n\n```\n// Language: Clean\n\nfib :: Int -\u003e Int\nfib    n\n| n == 1   =  1\n| n == 2   =  1\n| n \u003e  2   =  fib (n - 1) + fib (n - 2)\n```\n\nThe function above is partial.\nIt results in a run-time error when invoked any integer less than one.\n\nThis partial behavior extends to a function definition as well.\n\n```\n// Language: Clean\n\nfib :: Int -\u003e Int\nfib    1   =  1\nfib    2   =  1\nfib    n   =  fib (n - 1) + fib (n - 2)\n```\n\nThis version also results in run-time error when invoked with $n\\le{0}$, even though it does not have guarded bodies.\n\n### Operators\n\nOperators are arity-two functions.\nThey can be applied in infix position or invoked like ordinary functions.\n\n```\n// Language: Clean\n\n1 + 1  // applied as an operator\n```\n\nTo invoke an operator as an ordinary function, the operator name must be placed inside parentheses, and in front of its argument.\n\n```\n// Language: Clean\n\n(+) 1 1  // invoked as an ordinary function\n```\n\nWhen applied in infix position, both arguments must be given.\nOperators can be curried, but only when they are invoked as ordinary functions.\n\n**Operator precedence**\n\nThe precedence determines how tightly an operator binds to its argument.\nPrecedence can be between zero and nine with higher number having higher precedence.\n\nThe precedence of an operator is nine by default.\n\n**Operator fixity**\n\nThe fixity is important when evaluating two operators of the same precedence.\nThere are two relevant fixities:\n\n- $\\textbf{infixl}$ for left-associated operators, and\n- $\\textbf{infixr}$ for right-associated operators.\n\nThe fixity is left-associated by default.\n\n**Defining an operator**\n\nAn operator can be defined by placing its name between parentheses.\nIt can be implemented as if it was an ordinary function.\n\n```\n// Language: Clean\n\n([fnName]) [fnParamL] [fnParamR] =  [fnBody]\n([fnName]) [fnParamL] [fnParamR] =\u003e [fnBody]\n```\n\nPrecedence and fixity of an operator can be defined in its type declaration, but they can be omitted.\n\n```\n// Language: Clean\n\n(-\u003e) infixr 9 :: Bool Bool  -\u003e Bool\n(-\u003e)             True False =  False\n(-\u003e)             _    _     =  True\n```\n\nDefinition with omitted fixity and precedence can be done as follow:\n\n```\n// Language: Clean\n\n(\u003c=\u003e) :: Bool Bool -\u003e Bool\n(\u003c=\u003e)    x    y    =  x == y\n```\n\n**Conflict between operators**\n\nIt is not allowed to apply operators with equal precedence in an expression in such a way that their fixity conflict.\n\n```\n// Language: Clean\n\nTrue -\u003e False \u003c=\u003e False\n```\n\nThe $\\rightarrow$ operator is a right-associated.\nIt implies that the expression should be evaluated as follows.\n\n```\n// language: Clean\n\nTrue -\u003e (False \u003c=\u003e False)\n```\n\nHowever, the $\\iff$ operator is left associated.\nIt implies that the expression should be evaluated as follows.\n\n```\n// language: Clean\n\n(True -\u003e False) \u003c=\u003e False\n```\n\nSince both operators have the same precedence and the order of evaluation cannot be decided by their fixity, this expression will result in a compile-time error.\n\n### Lambda Functions\n\nA lambda function is defined \"on the spot\" as an expression.\nHowever, it cannot have local definitions or guards.\n\nA lambda function has following syntax.\n\n```\n// Language: Clean\n\n\\[fnParam] =  [fnBody]\n\\[fnParam] -\u003e [fnBody]\n```\n\nParameters of a lambda function are separated by spaces.\n\n```\n// Language: Clean\n\n\\paramA        = ...\n\\paramA paramB = ...\n```\n\n### Case Expressions\n\nIn a $\\textbf{case..in}$ expression, cases are tried in textual order.\nEach case contains a pattern and a case body.\n\n```\n// Language: Clean\n\ncase [expr] of\n[casePatternA] =  [caseBodyA]\n[casePatternB] =  [caseBodyB]\n[casePatternC] =  [caseBodyC]\n\ncase [expr] of\n[casePatternX] -\u003e [caseBodyX]\n[casePatternY] -\u003e [caseBodyY]\n[casePatternZ] -\u003e [caseBodyZ]\n```\n\nGuards can be introduce to a case which allows a case to have multiple guarded bodies.\n\n```\n// Language: Clean\n\ncase [expr] of\n[patternA]\n| [guardA] = [bodyAA]\n| [guardB] = [bodyAB]\n| [guardC] = [bodyAC]\n[patternB] = [bodyB]\n```\n\nInternally, a $\\textbf{case..in}$ expression is translated to a function definition.\nThe cases are transformed into an implementation.\n\n```\n// language: Clean\n\n_caseFn [casePatternA] = [caseBodyA]\n_caseFn [casePatternB] = [caseBodyB]\n_caseFn [casePatternC] = [caseBodyC]\n```\n\nConsequently, this can result in a run-time error when none of pattern matches since the expression is translated into a partial function.\n\n### Pattern-Match Expressions\n\nA pattern-match expression checks an expression against a pattern or not.\n\n```\n// Language: Clean\n\n[expr] := [pattern]\n```\n\nInternally, it compiles down to a $\\textbf{case..of}$ expression.\nIt yields $\\textbf{True}$ or $\\textbf{False}$ similar to an equality check.\n\n```\n// Language: Clean\n\ncase [expr] of\n[pattern] = True\n_         = False\n\n```\n\nIt is useful when dealing with algebraic types.\n\n```\n// Language: Clean\n\n:: Tree a = Node a (Tree a) (Tree a)\n          | Leaf\n\nisLeaf :: (Tree a) -\u003e Bool\nisLeaf    t        =  t := (Leaf)\n\nisNode :: (Tree a) -\u003e Bool\nisNode    t        =  t := (Tree x l r)\n```\n\n### Local Definitions\n\n#### Let Expressions\n\nA $\\textbf{let}..\\textbf{in}$ expression introduces a new scope inside an expression.\n\n```\n// Language: Clean\n\nlet\n    localX  = ...\n    localY = ...\nin expr\n```\n\nAnything defined inside a $\\textbf{let}..\\textbf{in}$ expression only has meaning in $\\text{expr}$.\n\n```\n// Language: Clean\n\n[let \n    a = i * i \nin (a, a) \\\\ i \u003c- [0..n]]\n```\n\n#### Where Blocks\n\nA $\\textbf{where}$ block can be added at the end of a function implementation which introduces a new scope.\n\n```\n// Language: Clean\n\n[fnName] [fnParam]\n| [guardA] = [bodyA]\n| [guardB] = [bodyB]\n| [guardC] = [bodyC]\nwhere\n    localX = [expr]\n```\n\nFor example:\n\n```\n// Language: Clean\n\nabsolute :: Int -\u003e Int\nabsolute    0   =  z  // 1st impl\nwhere\n    z :: Int\n    z =  0\nabsolute    n         // 2nd impl\n| n \u003c  0        =  negN\n| otherwise     =  n\nwhere\n    negN :: Int\n    negN =  n * (-1)\n```\n\nThe second implementation does not have access to $\\text{z}$ which is defined in the first implementation.\n\n#### With Blocks\n\nA $\\textbf{with}$ block can be added at the end of a guarded body which introduces a new scope.\n\n```\n// language: Clean\n\n[fnName] [fnParam]\n| [guardA] = [bodyA]\nwith\n    localX = [expr]\n| [guardB] = [bodyB]\nwith\n    localY = [expr]\n| [guardC] = [bodyC]\n```\n\nFor example:\n\n```\n// Language: Clean\n\nabsolute :: Int -\u003e Int\nabsolute    n\n| n == 0        =  0\n| n \u003c  0        =  negN\nwith\n    negN :: Int\n    negN =  n * (-1)\n| otherwise     =  n\n```\n\nThe third guarded body does not have access to $\\text{negN}$, which is local to the second guarded body.\n\n\n\n---\n\n## Built-In Types\n\nCertain types like integers, Booleans, characters, real numbers, lists, tuples and arrays are frequently used that they have been predefined for reasons of efficiency and convenience.\n\n### Primitive Types\n\n#### Integers\n\n**Type annotation**: $\\textbf{Int}$\n\n**Constructors**\n\nFrom decimal notation:\n\n```\n// Language: Clean\n\nn :: Int\nn = -13\nn =  0\nn =  13\n```\n\nFrom octal notation by prefixing octal digits with $\\textbf{0}$:\n\n```\n// Language: Clean\n\nn :: Int\nn = -015  // dec -13\nn =  0\nn =  015  // dec  13\n```\n\nFrom hexadecimal notation by prefixing hexadecimal digits with $\\textbf{0x}$:\n\n```\n// Language: Clean\n\nn :: Int\nn = -0xD  // dec -13\nn =  0\nn =  0xd  // dec  13\n```\n\nMore information about built-in operations and functions on integers can be found on [Appendix A: StdInt](appendix-a/stdint.md).\n\n#### Real Numbers\n\n**Type annotation**: $\\textbf{Real}$\n\n**Constructors**\n\nFrom decimal notation:\n\n```\n// Language: Clean\n\nn :: Real\nn = -1.3\nn =  0.0\nn =  1.3\n```\n\nFrom scientific notation:\n\n```\n// Language: Clean\n\nn :: Real\nn = -13E-2  // -0.13\nn =  0E0    //  0\nn =  13E-2  //  0.13\n```\n\nMore information about built-in operations and functions on real numbers can be found on [Appendix A: StdReal](appendix-a/stdreal.md).\n\n#### Booleans\n\n**Type annotation**: $\\textbf{Bool}$\n\n**Constructors**\n\n```\n// Language: Clean\n\nb :: Bool\nb =  True\nb =  False\n```\n\nMore information about built-in operations and functions on Booleans can be found on [Appendix A: StdBool](appendix-a/stdbool.md).\n\n#### Characters\n\n**Type annotation**: $\\textbf{Char}$\n\n**Constructors**\n\n```\n// Language: Clean\n\nc :: Char\nb =  'a'\nb =  '9'\nb =  'Z'\nb =  '+'\n```\n\nMore information about built-in operations and functions on characters can be found on [Appendix A: StdChar](appendix-a/stdchar.md).\n\n#### Parameter-Matching Primitive Types\n\nConstants of primitive types can be specified as pattern.\n\nUsing integer constants as pattern:\n\n```\n// Language: Clean\n\nfib :: Int -\u003e Int\nfib    1   =  1\nfib    2   =  1\nfib    n   =  fib (n - 1) + fib (n - 2)\n```\n\nUsing character constants as pattern:\n\n```\n// Language: Clean\n\nisLetterA :: Char -\u003e Bool\nisLetterA    'a'  =  True\nisLetterA    'A'  =  True\nisLetterA     _   =  False\n```\n\n### Lists\n\n#### Defining A List\n\n**Type annotation**:\n$[\\textbf{Int}]$,\n$[\\textbf{Char}]$,\n$[\\textbf{T}]$,\net cetera.\n\nA list can contain an infinite number of elements.\nAll elements must be of the same type.\n\n**Constructors**\n\nFrom explicit enumeration of the elements:\n\n```\n// Language: Clean\n\n[1, 3, 5, 7, 9]\n[1 : [3, 5, 7, 9]]\n[1, 3, 5 : [7, 9]]\n[1 : [3 : [5 : [7 : [9 : []]]]]]\n[1 : 3 : 5 : 7 : 9 : []]\n```\n\nFrom implicit enumeration with $\\textbf{dot-dot}$ expression:\n\n```\n// Language: Clean\n\n[1..]       // infitite list [1, 2, 3, ...]\n[1, 3..]    // infinite list [1, 3, 5, ...]\n[1..5]      // [1, 2, 3, 4, 5]\n[1, 3..10]  // [1, 3, 5, 7, 9]\n```\n\nIt should be noted that $\\textbf{dot-dot}$ expressions requires $\\text{StdEnum}$ module.\n\nFrom list comprehension:\n\n```\n// Language: Clean\n\n// extract from a list\n[el \\\\ el \u003c- list]\n\n// extract from an array\n[el \\\\ el \u003c-: array]\n\n// cartesian product\n[(x, y) \\\\ x \u003c- xs , y \u003c- ys]\n\n// pair-wise zip\n[(x, y) \\\\ x \u003c- xs \u0026 y \u003c- ys]\n\n// same as filter\n[x \\\\ x \u003c- xs | P x]\n\n// nested\n[(x, y) \\\\ x \u003c- xs, y \u003c- [1..x]]\n```\n\nA special notation for constructing a list of characters is also provided:\n\n```\n// Language: Clean\n\n['a', 'b', 'c']\n['abc']\n['ab','c']\n```\n\nMore information about built-in operations and functions on lists can be found on:\n\n- [Appendix A: StdCharList](appendix-a/stdcharlist.md),\n- [Appendix A: StdList](appendix-a/stdlist.md), and\n- [Appendix A: StdOrdList](appendix-a/stdordlist.md).\n\n#### List Patterns\n\nLists can be specified as patterns as follow:\n\n```\n// Language: Clean\n\ngetFst :: [T]       -\u003e T\ngetFst    [x, y, z] =  x\n\ngetSnd :: [T]       -\u003e T\ngetSnd    [x, y, z] =  y\n\ngetThd :: [T]       -\u003e T\ngetThd    [x, y, z] =  z\n```\n\nThe results of these function calls are as expected:\n\n```\n// Language: Clean\n\ngetFst [1, 2, 3]  // 1\ngetSnd [1, 2, 3]  // 2\ngetThd [1, 2, 3]  // 3\n```\n\nHowever, they will result in a run-time error if it is invoked with a list which does not have exactly three elements.\n\n```\n// Language: Clean\n\ngetFst [1]          // NOT OK :(\ngetSnd [1, 2]       // NOT OK :(\ngetThd [4, 3, 2, 1] // NOT OK :(\n```\n\nTo remedy this issue, an addition element should be introduce.\n\n```\n// Language: Clean\n\ngetFstAny :: [T]     -\u003e T\ngetFstAny    [x : r] =  x\n\ngetSndAny :: [T]        -\u003e T\ngetSndAny    [x, y : r] =  y\n\ngetThdAny :: [T]           -\u003e T\ngetThdAny    [x, y, z : r] =  z\n```\n\nThe right-hand side of colon ($:$) matches with any number of elements, including zero.\nIt is worth noting that $r$ is always a list.\n\n```\n// Language: Clean\n\ngetFstAny [1]           // x = 1\n                        // r = []\n\ngetFstAny [1, 2]        // x = 1\n                        // r = [2]\n\ngetFstAny [4, 3, 2, 1]  // x = 4\n                        // r = [3, 2, 1]\n```\n\nHowever, the second function still requires the list to have at least two elements.\n\n```\n// Language: Clean\n\ngetSndAny [1]           // NOT OK :(\n\ngetSndAny [1, 2]        // x = 1\n                        // y = 2\n                        // r = []\n\ngetSndAny [4, 3 ,2 ,1]  // x = 4\n                        // y = 3\n                        // r = [2, 1]\n```\n\nSimilarly, the third function requires a list with at least three elements.\n\n```\n// Language: Clean\n\ngetThdAny [1]           // NOT OK :(\n\ngetThdAny [1, 2]        // NOT OK :(\n\ngetThdAny [4, 3, 2, 1]  // x = 4\n                        // y = 3\n                        // z = 2\n                        // r = [1]\n```\n\n### Tuples\n\n#### Defining A Tuple\n\n**Type annotation**:\n$(\\textbf{T},\\ \\textbf{K})$,\n$(\\textbf{T},\\ \\textbf{K},\\ \\textbf{V})$,\n$(\\textbf{T},\\ \\textbf{K},\\ \\textbf{V},\\ \\textbf{E})$\net cetera.\n\nA tuple contains finite number of elements.\nElements do not have to be the same type.\nEvery type appears in a tuple must be specified, and singleton tuples are not allowed.\n\n**Constructors**\n\n```\n// Language: Clean\n\nA :: (Int, Char)\nA =  (49, '1')\n\nB :: (Real, Bool, String)\nB =  (0.2, False, \"Hi\")\n\nC :: (Int)\nC =  (2, 6)  // NOT OK should be (Int, Int)\n\nD :: (Int)\nD =  (2)     // NOT OK\n```\n\nMore information about built-in operations and functions on lists can be found on:\n\n- [Appendix A: StdTuple](appendix-a/stdtuple.md).\n\n#### Tuple Patterns\n\nTuples can be used as patterns in a similar way to lists.\nHowever, colon ($:$) is not allowed in tuple patterns.\n\n```\n// Language: Clean\n\ngetFst :: (T, K, V) -\u003e T\ngetFst    (x, y, z) =  x\n\ngetSnd :: (T, K, V) -\u003e K\ngetSnd    (x, y, z) =  y\n\ngetThd :: (T, K, V) -\u003e V\ngetThd    (x, y, z) =  z\n```\n\nThe results of these function calls are as expected:\n\n```\n// Language: Clean\n\ngetFst (1, 'a', 1.0)  // 1\ngetSnd (1, 'a', 1.0)  // 'a'\ngetThd (1, 'a', 1.0)  // 1.0\n```\n\n### Arrays\n\n#### Defining An Array\n\n**Type annotation**:\n$\\{\\textbf{Int}\\}$,\n$\\{\\textbf{Char}\\}$,\n$\\{\\textbf{T}\\}$,\net cetera.\n\nAn array contains a finite number of elements.\nElements of an array have to be of the same type.\n\n**Constructors**\n\n```\n// Language: Clean\n\n{1, 2, 3, 4}\n{1.0, 2.0, 3.0, 4.0}\n\n\"abc\"\n// equivalent to\n// {'a', 'b', 'c'}\n```\n\nAn array can be constructed from comprehension by surrounding a comprehension with $\\{\\ldots\\}$.\n\nMore information about built-in operations and functions on lists can be found on:\n\n- [Appendix A: StdArray](appendix-a/stdarray.md), and\n- [Appendix A: StdString](appendix-a/stdstring.md).\n\n---\n\n## Defining New Types\n\nAs a strongly typed language, every object and function in CLEAN has a type.\nThe basic can be extended with algebraic types, record types, abstract types and synonym types.\n\nNew types can only be defined on the global level.\n\n### Algebraic Data Types\n\n#### Defining An Algebraic Data Type\n\nAn algebraic data type introduces a new data structure and a constructor.\n\nIt has the following syntax.\n\n```\n// Language: Clean\n\n:: [tName] = [tConstructor]\n```\n\nAn algebraic data type can have multiple constructors.\nConstructors defined in the same global scope must have names.\nConstructors must be separated by a vertical bar ($|$).\n\n```\n// Language: Clean\n\n:: [tName] = [tConstructorA] | [tConstructorB] | [tConstructorC]\n```\n\nFor readability, constructors may be placed on different lines.\n\n```\n// Language: Clean\n\n:: [tName] = [tConstructorA]\n           | [tConstructorB]\n           | [tConstructorC]\n```\n\nFor example, a basic algebraic type can be defined as follows.\n\n```\n// Language: Clean\n\n:: Mood = Happy | Sad\n```\n\nConstructors also accept types as arguments, but they must be declared on the left-hand side.\nOnce declared, these generic types can be referred to by any of its constructors.\n\n```\n// language: Clean\n\n:: [tName] T K = [tConstructorA] T\n               | [tConstructorB] K\n               | [tConstructorC] T K\n```\n\nFor example, a binary tree, which is has a recursive structure can be defined as follows.\n\n```\n// language: Clean\n\n:: Tree = Branch Tree Tree\n        | Leaf\n```\n\nAn infix constructor is defined by surrounding its name with parentheses.\nThey must have an arity of two.\nThe precedence and fixity of an such constructor follows that of an operator, which is discussed in Chapter I.\n\n```\n// Language: Clean\n\n:: [tName] T K =  [tConstructorA]  T\n               |  [tConstructorB]  K\n               | ([tConstructorC]) T K\n\n:: [tName] T K =  [tConstructorA]  T\n               |  [tConstructorB]  K\n               | ([tConstructorC]) [fixity] [precedence] T K\n```\n\nFor example, the $\\text{Branch}$ constructor can be rewritten as an infix constructor.\n\n```\n// language: Clean\n\n:: TreeInfix = (/\\) infixr 0 Tree Tree\n             | Leaf\n```\n\nThe precedence and fixity of an infix constructor can be omitted.\nThe default precedence is $9$, and the default fixity is $\\textbf{infixl}$.\n\n```\n// language: Clean\n\n:: TreeInfix = (/\\) Tree Tree\n             | Leaf\n```\n\n#### Creating Objects Of Algebraic Data Types\n\nObjects of simple algebraic data types are created by invoking one of its constructors.\n\n```\n// Language: Clean\n\n:: Mood = Sad | Happy\n\nA :: Mood\nA =  Happy\n\nB :: Mood\nB =  Sad\n```\n\nIf a constructor accepts arguments, it should be invoked with appropriate arguments.\n\n```\n// Language: Clean\n\n:: Tree = Branch Tree Tree\n        | Leaf\n\nA :: Tree\nA =  Leaf\n\nB :: Tree\nB =  Branch Leaf Leaf\n\nC :: Tree\nC =  Branch Leaf (Branch Leaf Leaf)\n```\n\nInfix constructors behave in a similar way.\n\n```\n// language: Clean\n\n:: TreeInfix = (/\\) TreeInfix TreeInfix\n               | Leaf\n\nA :: TreeInfix\nA =  Leaf\n\nB :: TreeInfix\nB =  Leaf /\\ Leaf\n\nC :: TreeInfix\nC =  (/\\) Leaf Leaf\n\nD :: TreeInfix\nD =  Leaf /\\ (Leaf /\\ Leaf)\n```\n\n#### Algebraic Data Type Patterns\n\nTo use a algebraic data type as a pattern, use its constructors.\n\n```\n// Language: Clean\n\n:: Mood = Sad | Happy\n\nisHappy :: Mood    -\u003e Bool\nisHappy    (Happy) =  True\nisHappy    _       =  False\n```\n\nWith the same process, complex algebraic data types can be used as patterns as well.\n\n```\n// Language: Clean\n\n:: Tree = Branch Tree Tree\n        | Leaf\n\nisBranch :: Tree           -\u003e Bool\nisBranch    (Branch l r)   =  True\nisBranch    _              =  False\n\n:: TreeInfix = (/\\) TreeInfix TreeInfix\n               | Leaf\n\nisBranchInfix :: TreeInfix -\u003e Bool\nisBranchInfix   (l/\\r)     =  True\nisBranchInfix   _          =  False\n```\n\n### Record Types\n\nA record type is an algebraic data type in which exactly one constructor is defined.\nA field name is attached to each of the arguments of the constructor.\n\n#### Defining A Record Type\n\nA record type is a tuple-like algebraic data structure that has the advantage that its elements can be selected by field name rather than by position.\n\nA simple record type can be defined as follows.\n\n```\n// Language: Clean\n\n:: [tName] = { [fieldName] :: [fieldType] }\n```\n\nFields must be separated commas ($,$).\n\n```\n// Language: Clean\n\n:: [tName] = { [fNameA] :: [fTypeA] , [fNameB] :: [fTypeB] , [fNameC] :: [fTypeC]  }\n```\n\nTo increase readability, fields can be placed on different lines.\n\n```\n// Language: Clean\n\n:: [tName] = { [fNameA] :: [fTypeA]\n             , [fNameB] :: [fTypeB]\n             , [fNameC] :: [fTypeC]\n             }\n```\n\nFor example, a record type for representing complex numbers can be defined as follows.\n\n```\n// Language: Clean\n\n:: Complex = { re :: Real\n             , im :: Real\n             }\n```\n\n#### Creating Objects Of Record Types\n\nThe field names are case-sensitive, but the field order does not matter.\nEvery field of a record type must be given.\n\n```\n// Language\n\n:: Complex = { re :: Real\n             , im :: Real\n             }\n\nA :: Complex\nA =  { re = 1.0 , im = 0.0 }\n\nB :: Complex\nB =  { im = 1.0 , re = 0.0}\n```\n\nThe name of a record type can be added to the constructor.\nIn such a case, the type annotation can be omitted.\n\n```\n// Language: Clean\n\n:: Point = { x :: Int\n           , y :: Int\n           }\n\n:: Position = { x :: Int\n              , y :: Int\n              }\n\n// A :: Point\n// A =  { x = 0 , y = 0 }\nA =  { Point | x = 0 , y = 0 }\n\n// B :: Position\n// B =  { x = 0 , y = 0 }\nB =  { Position | x = 0 , y = 0 }\n```\n\n**Record update**\n\nA new record object can be constructed from an existing one.\n\n```\n// Language: Clean\n\n{ [oldObject] \u0026 [fName] = [newValue] }\n```\n\nMultiple fields can be updated all at once.\n\n```\n// Language: Clean\n\n{ [oldObject] \u0026 [fNameA] = [newValueA] , [fNameB] = [newValueB] }\n```\n\nFor example:\n\n```\n// Language: Clean\n\n:: PosThree = { x :: Int\n              , y :: Int\n              , z :: Int\n              }\n\nA :: PosThree\nA =  { x = 0 , y = 0 , z = 0 }  // (PosThree 0 0 0)\n\nB :: PosThree\nB =  { A \u0026 x = 1 , y = 1 }      // (PosThree 1 1 0)\n```\n\n#### Record Type Patterns\n\nAn object of type record can be specified as pattern.\nNot every field must be used.\n\n```\n// Language: Clean\n\n:: PosThree = { x :: Int\n              , y :: Int\n              , z :: Int\n              }\n\nisZeroX :: PosThree -\u003e Bool\nisZeroX    { x=0 }  =  True\nisZeroX    _        =  False\n\nA :: PosThree\nA =  { x = 0 , y = 0 , z = 0 }\n\nisZeroX A  // True\n\nB :: PosThree\nB =  { A \u0026 x = 1 , y = 1 }\n\nisZeroX B  // False\n```\n\nAlternatively, record fields can be extracted without patterns.\n\n```\n// Language: Clean\n\n:: PosThree = { x :: Int\n              , y :: Int\n              , z :: Int\n              }\n\nisZeroY :: PosThree -\u003e Bool\nisZeroY    { y=r }    =  r == 0\n```\n\nIn the implementation above, the record field $y$ is extracted to $r$.\nIt can be used referred by the body.\n\nRecord fields can be extracted to an identifier of the same name.\n\n```\n:: PosThree = { x :: Int\n              , y :: Int\n              , z :: Int\n              }\n\nisZeroZ :: PosThree -\u003e Bool\nisZeroZ    { z }    =  z == 0\n```\n\nThe implementation above is equivalent to the following:\n\n```\n// Language: Clean\n\nisZeroZ :: PosThree -\u003e Bool\nisZeroZ    { z=z }  =  z == 0\n```\n\n**Record field selection**\n\nThe value of a record field can be selected using dot operator ($.$).\n\n```\n// Language: Clean\n\n[recordObj].[fName]\n```\n\nFor example, a simple getter function on $\\textbf{Point}$ can be defined as follows.\n\n```\n:: Point = { x :: Int\n           , y :: Int\n           }\n\ngetX :: Point -\u003e Int\ngetX    p     =  p.x\n\nA :: Point\nA =  { x = 1 , y = 0 }\n\ngetX a  // 1\n```\n\n### Synonym Types\n\nSynonym types allow for an introduction of a new type name for an existing type.\n\n#### Defining A Synonym Type\n\nA simple synonym type has the follow syntax:\n\n```\n// Language: Clean\n\n:: [tName] :== [existingType]\n```\n\nFor example, an array of characters can be viewed as a string.\n\n```\n// Language: Clean\n\n:: String :== {Char}\n```\n\nSynonym types also accept generic types as arguments.\n\n```\n// Language: Clean\n\n:: [tName] T K :== [existingType] T K\n```\n\nFor example, an arity-two operator can be shortened with a synonym type.\n\n```\n// Language: Clean\n\n:: Op T :== T T -\u003e T\n\n// add :: Int Int -\u003e Int\nadd :: (Op Int)\n```\n\n---\n\n## Overloading\n\n### Overloaded Operators And Functions\n\nFunctions and operators are defined on built-in types.\nHowever, when interacting with custom data types, they do not have any defined function or operator.\n\nThat is, adding two objects of $\\textbf{Complex}$ type is not allowed.\n\n```\n// Language: Clean\n\n:: Complex = { re :: Real\n             , im :: Real\n             }\n\na :: Complex\na =  { re = 0.0 , im = 1.0 }\n\nb :: Complex\nb =  { re = 0.0 , im = 1.0 }\n\na + b  // NOT OK :(\n```\n\nThis happens because addition is not defined on $\\textbf{Complex}$ type.\n\nIn this case, addition can be overloaded on $\\textbf{Complex}$ type.\n\n```\n// Language: Clean\n\ninstance + Complex\nwhere\n    (+) x y = { Complex | re=(x.re + y.re) , im=(x.im + y.im)}\n\na + b  // (Complex 0.0 2.0)\n```\n\nOnly after overloading the addition operation on $\\textbf{Complex}$ that the addition is allowed.\nIn other word, the complier now knows the meaning of complex number addition.\n\nA list of functions and operations which can be overloaded can be found on [Appendix A: StdOverloaded](appendix-a/stdoverloaded.md).\n\n#### Defining An Overloaded Function Or Operator\n\nTo overload the built-in functions and operations, the general syntax is as follows.\n\n```\n// Language: Clean\n\ninstance [clsName] [typeVars]\nwhere\n    [fnImplementation]\n    [opImplementation]\n```\n\nFunctions and operators can be defined in terms of existing overloaded functions.\nThis is especially useful when dealing with generic types.\n\n```\n// Language: Clean\n\nincrement :: T -\u003e T\nincrement    x =  x + 1\n```\n\nIt is adding an object of type $\\textbf{T}$ and $1$ which is an integer.\nUnless the addition is instantiated for mentioned types, this implementation would not work as intended.\n\nOne way to ensure that it works for all type is to introduce class context.\n\n```\nincrement :: T -\u003e T | + T \u0026 one T\nincrement    x =  x + one\n```\n\nThe new implementation requires that the addition operation, as well as, $\\textbf{one}$ unit is defined on a generic type $\\textbf{T}$.\n\nIn this case, the function is defined in terms of an overloaded function and a unit.\n\nSuch declaration has the following syntax.\n\n```\n// Language: Clean\n\n[fnName] :: [typeVars] -\u003e [typeVar] | [clsConstraints]\n```\n\nClass constraints are separated by ampersands ($\\\u0026$).\n\n### Classes\n\nA class gives name to a group of overloaded functions and operators.\nThese functions and operators are members of the class.\n\n```\n// Language: Clean\n\nclass Equal T\nwhere\n    (==) infixl 4 :: T T -\u003e Bool\n    (\u003c\u003e) infixl 4 :: T T -\u003e Bool\n```\n\nThe class $\\text{Eq}$ has two members.\nThey are equality and inequality operators.\n\nTo instantiate a class, all of its members must be implemented.\n\n```\n// Language: Clean\n\ninstance Equal Complex\nwhere\n    (==) x y = (x.re == y.re) \u0026\u0026 (x.im == y.im)\n    (\u003c\u003e) x y = (x.re \u003c\u003e y.re) || (x.im \u003c\u003e y.im))\n```\n\nA list of classes can be found on [Appendix A: StdClass](appendix-a/stdclass.md).\n\n[[appendix-a/stdclass|stdclass]]\n\n#### Defining A Class\n\nAs shown above, a class simple provides a name to collection of logically-linked functions and operations.\n\nIt can be defined with the following syntax.\n\n```\n// Language: Clean\n\nclass [clsName] [typeVars]\nwhere\n    [fnDeclaration]\n    [opDeclaration]\n```\n\nType variables declared can be referred to by all of its member, but they must be given as arguments when the class is instantiated.\n\n```\n// Language: Clean\n\nclass MinMaxC T K\nwhere\n    minC :: T T -\u003e K\n    maxC :: T T -\u003e K\n\ninstance MinMax Real Int\nwhere\n    minC x y = toInt (min x y)\n    maxC x y = toInt (max x y)\n```\n\n--- \n\n## Appendix A: Standard Environment\n\nMore information about Standard Environment can be found [here](appendix-a.md)","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a":{"title":"Appendix A: Standard Environment","content":"\n## Introduction\n\nThis section is referred to by other parts of the reference to increase readability and clarity.\nIt is a summary of the Standard Environment provided by creators of CLEAN.\nSome functions which can be easily synthesized from other functions are omitted.\n\nThe Standard Environment includes, but not limited to, the following modules:\n\n- [StdArray](appendix-a/stdarray.md)\n- [StdBool](appendix-a/stdbool.md)\n- [StdChar](appendix-a/stdchar.md)\n- [StdCharList](appendix-a/stdcharlist.md)\n- [StdClass](appendix-a/stdclass.md)\n- [StdInt](appendix-a/stdint.md)\n- [StdList](appendix-a/stdlist.md)\n- [StdOrdList](appendix-a/stdordlist.md)\n- [StdOverloaded](appendix-a/stdoverloaded.md)\n- [StdReal](appendix-a/stdreal.md)\n- [StdString](appendix-a/stdstring.md)\n- [StdTuple](appendix-a/stdtuple.md)\n\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdarray":{"title":"Appendix A: StdArray","content":"\n## Basic Operations\n\n### Indexing\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{i}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere :\n- $A$ is of type $\\{\\textbf{T}\\}$,\n- $i$ is of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns element at $i$-th index of $A$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nRun Time Error: index out of range\n```\n\n**Usage**\n\n```\n// Language: Clean\n \n\"abcde\".[5]     // NOT OK :(\n\"abcde\".[2]     // 'c'\n\"abcde\".[0]     // 'a'\n\"abcde\".[(-1)]  // NOT OK :(\n```\n\n### Update At\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{i}\\rightarrow{a}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere :\n- $A$ and $R$ are of type $\\{\\textbf{T}\\}$,\n- $i$ is of type $\\textbf{Int}$, and\n- $a$ is of type $\\textbf{T}$.\n\n**Behavior**: updates element at $i$-th index of $A$ with $a$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nRun Time Error: index out of range\n```\n\n**Usage**\n\n```\n// Language: Clean\n \n{\"abcde\" \u0026 [5] = 'X'}     // NOT OK :(\n{\"abcde\" \u0026 [2] = 'C'}     // \"abCde\"\n{\"abcde\" \u0026 [0] = 'A'}     // \"Abcde\"\n{\"abcde\" \u0026 [(-1)] = 'X'}  // NOT OK :(\n\n{\"abcde\" \u0026 [0] = 'A', [1] = 'B'}\n// \"ABcde\"\n```\n\n---\n\n## Basic Functions\n\n### `select`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{i}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $\\{\\textbf{T}\\}$,\n- $i$ is of type $\\textbf{Int}$, and\n- $R$ are of type $\\textbf{T}$.\n\n**Behavior**: returns the $i$-th element of $A$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nRun Time Error: index out of range\n```\n\n**Usage**\n\n\n```\n// Language: Clean\n \nselect \"abcde\" 5     // NOT OK :(\nselect \"abcde\" 2     // 'c'\nselect \"abcde\" 0     // 'a'\nselect \"abcde\" (-1)  // NOT OK :(\n```\n\n### `size`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $\\{\\textbf{T}\\}$,\n- $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns size of $A$.\n\n**Usage**\n\n\n```\n// Language: Clean\n \nsize \"abcde\"  // 5\nsize \"abcd\"   // 4\nsize \"abc\"    // 3\nsize \"ab\"     // 2\n```\n\n### `update`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{i}\\rightarrow{a}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere :\n- $A$ and $R$ are of type $\\{\\textbf{T}\\}$,\n- $i$ is of type $\\textbf{Int}$, and\n- $a$ is of type $\\textbf{T}$.\n\n**Behavior**: updates element at $i$-th index of $A$ with $a$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nRun Time Error: index out of range\n```\n\n**Usage**\n\n```\n// Language: Clean\n \nupdate \"abcde\"   5  'X'  // NOT OK :(\nupdate \"abcde\"   2  'C'  // \"abCde\"\nupdate \"abcde\"   0  'A'  // \"Abcde\"\nupdate \"abcde\" (-1) 'X'  // NOT OK :(\n```\n\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdbool":{"title":"Appendix A: StdBool","content":"\n## Logical Operations \n\n### Logical NEGATE\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Bool}$.\n\n**Behavior**: negates the logical value of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nnot True        // False\nnot False       // True\nnot (not True)  // True\n```\n\n### Logical AND\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Bool}$.\n\n**Behavior**: returns true if and only if both $a$ and $b$ are true.\n\n**Usage**\n\n```\n// Language: Clean\n\nTrue  \u0026\u0026 True   // True\nTrue  \u0026\u0026 False  // False\nFalse \u0026\u0026 True   // False\nFalse \u0026\u0026 False  // False\n```\n\n### Logical OR\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Bool}$.\n\n**Behavior**: returns false if and only if both $a$ and $b$ are false.\n\n**Usage**\n\n```\n// Language: Clean\n\nTrue  || True   // True\nTrue  || False  // True\nFalse || True   // True\nFalse || False  // False\n```\n\n### Logical EQUIVALENCE\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Bool}$.\n\n**Behavior**: returns true if and only if both $a$ and $b$ share the same truth value.\n\n**Usage**\n\n```\n// Language: Clean\n\nTrue  == True   // True\nTrue  == False  // False\nFalse == True   // False\nFalse == False  // True\n```\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdchar":{"title":"Appendix A: StdChar","content":"\n## Arithmetic Operations \n\n### Addition\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Char}$.\n\n**Behavior**: $a$ and $b$ are converted to their ASCII values, then their sum is converted back to a character.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' + '1'  // 49 + 49 -\u003e  98 ('b')\n'A' + 'A'  // 65 + 65 -\u003e 130 ('é')\n'a' + 'a'  // 97 + 97 -\u003e 194 ('┬')\n```\n\n### Subtraction\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Char}$.\n\n**Behavior**: $a$ and $b$ are converted to their ASCII values, then result of their subtraction is converted back to a character.\n\n**Usage**\n\n```\n// Language: Clean\n\n'z' - '0'  // 122 - 48 -\u003e 74 ('J')\n'z' - '1'  // 122 - 49 -\u003e 73 ('I')\n'z' - '2'  //  97 + 50 -\u003e 72 ('H')\n```\n\n---\n\n## Relational Operations\n\n### Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$ are of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is lexicography equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' == 'A'  // False\n'a' == '1'  // False\n'A' == 'a'  // False\n'1' == '1'  // True\n```\n\n### Not Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$ are of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is lexicography not equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' \u003c\u003e 'A'  // True\n'a' \u003c\u003e '1'  // True\n'A' \u003c\u003e 'a'  // True\n'1' \u003c\u003e '1'  // False\n```\n\n### Less Than\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$ are of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is lexicography less than $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' \u003c 'A'  // True\n'a' \u003c '1'  // False\n'A' \u003c 'a'  // True\n'1' \u003c '1'  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$ are of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is lexicography less than or equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' \u003c= 'A'  // True\n'a' \u003c= '1'  // False\n'A' \u003c= 'a'  // True\n'1' \u003c= '1'  // True\n```\n\n### Greater Than\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$ are of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is lexicography greater than $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' \u003e 'A'  // False\n'a' \u003e '1'  // True\n'A' \u003e 'a'  // False\n'1' \u003e '1'  // False\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$ are of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is lexicography greater than or equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n'1' \u003e= 'A'  // False\n'a' \u003e= '1'  // True\n'A' \u003e= 'a'  // False\n'1' \u003e= '1'  // True\n```\n\n---\n\n## Basic Functions\n\n### `toUpper`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns upper case of $a$ if possible.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoUpper '1'  // '1'\ntoUpper 'a'  // 'A'\ntoUpper 'A'  // 'A'\ntoUpper '-'  // '-'\n```\n\n### `toLower`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns lower case of $a$ if possible.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoLower '1'  // '1'\ntoLower 'a'  // 'a'\ntoLower 'A'  // 'a'\ntoLower '-'  // '-'\n```\n\n---\n\n## Property Functions\n\n### `isLower`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is an lower case character or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisLower '1'  // False\nisLower 'a'  // True\nisLower 'A'  // False\nisLower '-'  // False\n```\n\n### `isUpper`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is an upper case character or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisUpper '1'  // False\nisUpper 'a'  // False\nisUpepr 'A'  // True\nisUpper '-'  // False\n```\n\n### `isAlphanum`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is alphanumeric or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisAlphanum '1'  // True\nisAlphanum 'a'  // True\nisAlphanum 'A'  // True\nisAlphanum '-'  // False\n```\n\n### `isAlpha`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is an alphabet or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisAlpha '1'  // False\nisAlpha 'a'  // True\nisAlpha 'A'  // True\nisAlpha '-'  // False\n```\n\n### `isDigit`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is a digit or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisDigit '1'  // True\nisDigit 'a'  // False\nisDigit 'A'  // False\nisDigit '-'  // False\n```\n\n### `isOctDigit`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is an octal digit or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisOctDigit '1'  // True\nisOctDigit '8'  // False\nisOctDigit 'a'  // False\nisOctDigit 'A'  // False\nisOctDigit '-'  // False\n```\n\n### `isHexDigit`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is a hexadecimal digit or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisHexDigit '1'  // True\nisHexDigit 'G'  // False\nisHexDigit 'a'  // True\nisHexDigit 'A'  // True\nisHexDigit '-'  // False\n```\n\n### `isAscii`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is an ASCII character or not.\nInternally, it checks whether the ASCII value of $a$ is less than $128$ or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisAscii '1'  // True\nisAscii 'a'  // True\nisAscii 'A'  // True\nisAscii '-'  // True\nisAscii 'Ç'  // False\n```\n\n### `isControl`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is a control character or not.\nInternally, it checks whether ASCII value of $a$ is between $[0,\\ 31]\\cup\\{127\\}$ or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisControl '1'   // False\nisControl 'a'   // False\nisControl 'A'   // False\nisControl '-'   // False\nisControl '\\t'  // True\n```\n\n### `isPrint`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is printable or not.\nInternally, it checks whether ASCII value of $a$ is between $[32,\\ 126]$ or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisPrint '1'  // True\nisPrint 'a'  // True\nisPrint 'A'  // True\nisPrint '-'  // True\nisPrint '\\t' // False\n```\n\n### `isSpace`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is a space character or not.\nInternally, it checks whether $a$ is one of the follow character of not:\n\n```\n' '  \n'\\t'\n'\\n'\n'\\r' \n'\\f'\n'\\v'\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nisSpace '1'   // False\nisSpace 'a'   // False\nisSpace 'A'   // False\nisSpace '-'   // False\nisSpace '\\t'  // True\n```\n\n---\n\n## Conversions To Characters\n\n### Integers To Characters\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{Char}$.\n\n**Behavior**: converts $a$ to its ASCII character.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoChar 49 // '1'\ntoChar 65 // 'A'\ntoChar 97 // 'a'\n```","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdcharlist":{"title":"Appendix A: StdCharList","content":" \n## Basic Functions\n\n### `cjustify`\n\n**Signature**\n\n$$\n\\begin{align*}\nn\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{Char}]$.\n\n**Behavior**: center-aligns $A$ with left and right spaces.\n\n**Usage**\n\n```\n// Language: Clean\n\ncjustify 5 ['a', 'b', 'c']  // [' ', 'a', 'b', 'c', ' ']\ncjustify 5 ['a', 'b']       // [' ', 'a', 'b', ' ', ' ']\ncjustify 3 ['a', 'b']       // ['a', 'b', ' ']\ncjustify 3 ['a']            // [' ', 'a', ' ']\ncjustify 1 ['a', 'b']       // ['a', 'b']\n```\n\n### `ljustify`\n\n**Signature**\n\n$$\n\\begin{align*}\nn\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{Char}]$.\n\n**Behavior**: left-aligns $A$ with spaces.\n\n**Usage**\n\n```\n// Language: Clean\n\nljustify 5 ['a', 'b', 'c']  // ['a', 'b', 'c', ' ', ' ']\nljustify 5 ['a', 'b']       // ['a', 'b', ' ', ' ', ' ']\nljustify 3 ['a', 'b']       // ['a', 'b', ' ']\nljustify 3 ['a']            // ['a', ' ', ' ']\nljustify 1 ['a', 'b']       // ['a', 'b']\n```\n\n### `rjustify`\n\n**Signature**\n\n$$\n\\begin{align*}\nn\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{Char}]$.\n\n**Behavior**: right-aligns $A$ with spaces.\n\n**Usage**\n\n```\n// Language: Clean\n\nrjustify 5 ['a', 'b', 'c']  // [' ', ' ', 'a', 'b', 'c']\nrjustify 5 ['a', 'b']       // [' ', ' ', 'a', 'b']\nrjustify 3 ['a', 'b']       // [' ', 'a', 'b']\nrjustify 3 ['a']            // [' ', ' ', 'a']\nrjustify 1 ['a', 'b']       // ['a', 'b']\n```\n\n### `flatlines`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{Char}]$.\n\n**Behavior**: joins elements of $A$ with newline characters.\n\n**Usage**\n\n```\n// Language: Clean\n\nflatlines [['a'], ['b']]  // ['a', '\\n', 'b', '\\n']\nflatlines ['a']           // ['a', '\\n']\nflatlines []              // []\n```\n\n### `mklines`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$,\n- $A$ is of type $[\\textbf{Char}]$, and\n- $R$ is of type $[[\\textbf{Char}]]$.\n\n**Behavior**: splits $A$ at newline characters.\n\n**Usage**\n\n```\n// Language: Clean\n\nmklines ['a', '\\n', 'b', '\\n']  // [['a'], ['b']]\nmklines ['a', '\\n']             // [['a']]\nmklines []                      // []\n```\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdclass":{"title":"Appendix A: StdClass","content":"\n## Arithmetic Classes\n\n### `PlusMin`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass PlusMin T | (+ T) \u0026 (- T) \u0026 (zero T)\n```\n\n### `MultDiv`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass MultDiv T | (* T) \u0026 (/ T) \u0026 (one T)\n```\n\n### `Arith`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass Arith T | (PlusMin T) \u0026 (MultDiv T) \u0026 (abs T) \u0026 (sign T) \u0026 (~ T)\n```\n\n### `IncDec`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass IncDec T | (+ T) \u0026 (- T) \u0026 (one T) \u0026 (zero T)\nwhere\n    inc :: T -\u003e T\n    inc    x =  x + one\n\n    dec :: T -\u003e T\n    dec    x =  x - one\n```\n\n### `Enum`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass Enum T | (\u003c T) \u0026 (IncDec T)\nwhere\n```\n\n---\n\n## Relational Classes\n\n### `Eq`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass Eq T | == T\nwhere\n    (\u003c\u003e) infixl 4 :: T T -\u003e Bool\n    (\u003c\u003e)             x y =  not (x == y)\n```\n\n### `Ord`\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass Ord T | \u003c T\nwhere\n    (\u003c=) infixl 4 :: T T -\u003e Bool\n    (\u003c=)             x y =  not (y \u003c x)\n    \n    (\u003e) infixl 4 :: T T -\u003e Bool\n    (\u003e)             x y =  y \u003c x\n    \n    (\u003e=) infixl 4 :: T T -\u003e Bool\n    (\u003e=)             x y =  not (x \u003c y)\n\n    min :: T T -\u003e T\n    min    x y =  case (x \u003c y) of \n                  True = x\n                  _    = y\n    \n    max :: T T -\u003e T\n    max    x y =  case (x \u003c y) of \n                  True = y\n                  _    = x\n```\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdint":{"title":"Appendix A: StdInt","content":"\n## Arithmetic Operations \n\n### Negation\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: inverts the sign of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n \n~  0   //  0\n~  1   // -1\n~(-1)  //  1\n```\n\n### Addition\n\n**Signature** \n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: adds $a$ and $b$ together.\n\n**Usage**\n\n```\n// Language: Clean\n\n  1  +   1   //  2\n  1  + (-1)  //  0\n(-1) +   1   //  0\n(-1) + (-1)  // -2\n```\n\n### Subtraction\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: subtracts $b$ from $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  1  -   1  //  0\n  1  - (-1) //  2\n(-1) -   1  // -2\n(-1) - (-1) //  0\n```\n\n### Multiplication\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: multiplies $a$ with $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  1  *   1  //  1\n  1  * (-1) // -1\n(-1) *   1  // -1\n(-1) * (-1) //  1\n```\n\n### Floor Division\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: floor divides $a$ with $b$.\nSilently crashes if $b$ is $0$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  1  /   1   //  1\n  1  / (-1)  // -1\n(-1) /   1   // -1\n(-1) / (-1)  //  1\n  7  /   0   //  NOT OK :(\n```\n\n### Reminder Division\n\nBoth $\\text{rem}$  and $\\text{mod}$ perform the same operation.\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns reminder of $a$ divides by $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n 3 mod -2  //  1\n-3 mod -2  // -1\n-3 mod  2  // -1\n 3 mod  2  //  1\n```\n\n### Exponentiation\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: raises $a$ to the $b$-th power.\nResults in a run-time error if $b$ is negative\n\nThe run-time error has the following message:\n\n```\n^ (Int) called with negative power argument\n```\n\n\n**Usage**\n\n```\n// Language: Clean\n\n  1  ^   1   //  1\n  1  ^ (-1)  //  NOT OK :(\n(-1) ^   1   // -1\n(-1) ^ (-1)  //  NOT OK :(  \n```\n\n---\n\n## Relational Operations\n\n### Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  ==   2   // False\n(-5) ==   2   // False\n  5  == (-2)  // False\n(-5) == (-2)  // False\n(-2) == (-2)  // True\n```\n\n### Not Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is not equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003c\u003e   2   // True\n(-5) \u003c\u003e   2   // True\n  5  \u003c\u003e (-2)  // True\n(-5) \u003c\u003e (-2)  // True\n(-2) \u003c\u003e (-2)  // False\n```\n\n### Less Than\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is less than $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003c   2   // False\n(-5) \u003c   2   // True\n  5  \u003c (-2)  // False\n(-5) \u003c (-2)  // True\n(-2) \u003c (-2)  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is less than or equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003c=   2   // False\n(-5) \u003c=   2   // True\n  5  \u003c= (-2)  // False\n(-5) \u003c= (-2)  // True\n(-2) \u003c= (-2)  // True\n```\n\n### Greater Than\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is greater than $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003e   2   // True\n(-5) \u003e   2   // False\n  5  \u003e (-2)  // True\n(-5) \u003e (-2)  // False\n(-2) \u003e (-2)  // False\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is greater than or equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003e=   2   // True\n(-5) \u003e=   2   // False\n  5  \u003e= (-2)  // True\n(-5) \u003e= (-2)  // False\n(-2) \u003e= (-2)  // True\n```\n\n---\n\n## Bitwise Operations\n\n### Bitwise NEGATE\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns bit-wise two complement of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nbitnot (-5)  // -4\nbitnot (-2)  //  1\nbitnot   2   //  -3\nbitnot   5   //  -6\n```\n\n### Bitwise OR\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns bit-wise OR of $a$ and $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  bitor   2   //  7\n(-5) bitor   2   // -5\n  5  bitor (-2)  // -1\n(-5) bitor (-2)  // -1\n```\n\n### Bitwise AND\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns bit-wise AND of $a$ and $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  bitand   2   //  0\n(-5) bitand   2   //  2\n  5  bitand (-2)  //  4\n(-5) bitand (-2)  // -6\n```\n\n### Bitwise XOR\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns bit-wise XOR of $a$ and $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  bitand   2   //  7\n(-5) bitand   2   // -7\n  5  bitand (-2)  // -5\n(-5) bitand (-2)  //  5\n```\n\n### Bitwise Left Shift\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: shifts $a$ to the left by $b$ bits.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003c\u003c   2   //  20\n(-5) \u003c\u003c   2   // -20\n  5  \u003c\u003c (-2)  //  4611686018427387904\n(-5) \u003c\u003c (-2)  // -4611686018427387904\n```\n\n### Bitwise Right Shift\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: shifts $a$ to the right by $b$ bits.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5  \u003e\u003e   2   //  1\n(-5) \u003e\u003e   2   // -2\n  5  \u003e\u003e (-2)  //  0\n(-5) \u003e\u003e (-2)  // -1\n```\n\n---\n\n## Basic Functions\n\n### `sign`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Int}$,.\n\n**Behavior**: returns sign of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nsign   1   //  1\nsign   0   //  0\nsign (-1)  // -1\n```\n\n### `abs`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns absolute value of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nabs   1   // 1\nabs   0   // 0\nabs (-1)  // 1\n```\n\n### `gcd`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns greatest common divisor of $a$ and $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\ngcd   3    2   // 1\ngcd (-3)   2   // 1\ngcd   3  (-2)  // 1\ngcd (-3) (-2)  // 1\n```\n\n### `lcm`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns least common multiple of $a$ and $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\nlcm   3    2   // 6\nlcm (-3)   2   // 6\nlcm   3  (-2)  // 6\nlcm (-3) (-2)  // 6\n```\n\n---\n\n## Property Functions\n\n### `isEven`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is an even integer or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisEven  2  // False\nisEven  1  // True\nisEven  0  // True\nisEven -1  // True\nisEven -2  // False\n```\n\n### `isOdd`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is an odd integer or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisOdd  2  // True\nisOdd  1  // False\nisOdd  0  // False\nisOdd -1  // False\nisOdd -2  // True\n```\n\n---\n\n## Conversions To Integers\n\n### Real Numbers To Integers\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Real}$, and\n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: rounds $a$ to its nearest integer.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoInt   1.5   //  2\ntoInt   1.4   //  1\ntoInt   0.0   //  0\ntoInt (-1.4)  // -1\ntoInt (-1.5)  // -2\n```\n\n### Characters To Integers\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: converts $a$ to its ASCII value.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoInt '1'  //  49\ntoInt '9'  //  59\ntoInt 'A'  //  65\ntoInt 'Z'  //  90\ntoInt 'a'  //  97\ntoInt 'z'  // 122\n```\n\n### Strings To Integers\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: converts a string $a$ to an integer. \nReturns $0$ if a decimal place is present.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoInt \"1.0\"   //  0\t\ntoInt \"1\"     //  1\ntoInt \"0\"     //  0\ntoInt \"-1\"    // -1\ntoInt \"-1.0\"  //  0\n```\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdlist":{"title":"Appendix A: StdList","content":"\n## Basic Operations \n\n### Concatenation\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$, $B$, and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: appends $B$ to the end of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n \n[1, 2, 3] ++ [4, 5]  // [1, 2, 3, 4, 5]\n[1, 2, 3] ++ [4]     // [1, 2, 3, 4]\n[1, 2, 3] ++ []      // [1, 2, 3]\n```\n\n### Indexing\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{i}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere :\n- $A$ is of type $[\\textbf{T}]$,\n- $i$ is of type $\\textbf{Int}$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns element at $i$-th index of $A$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nSubscript error in !!,index too large\n```\n\n**Usage**\n\n```\n// Language: Clean\n \n[1, 2, 3] !!   5   // NOT OK :(\n[1, 2, 3] !!   2   // 3\n[1, 2, 3] !!   0   // 1\n[1, 2, 3] !! (-1)  // NOT OK :(\n```\n\n### Slicing\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow(i, j)\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A, R$ are of type $[\\textbf{T}]$, and\n- $i, j$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns elements of $A$ which are inside $[i, j]$ interval.\n\n**Usage**\n\n```\n// Language: Clean\n \n[1, 2, 3] % (  2,  4)  // [3]\n[1, 2, 3] % (  0,  2)  // [1, 2, 3]\n[1, 2, 3] % ((-1), 0)  // [1, 2]\n[1, 2, 3] % ((-2), 5)  // [1, 2, 3]\n```\n\n---\n\n## Relational Operations\n\n### Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: checks if $A$ is equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     == []      // True\n[1, 2] == [1, 2]  // True\n[1, 2] == [1]     // False\n[1]    == [1, 2]  // False\n[1, 2] == [1, 3]  // False\n[1, 3] == [1, 2]  // False\n```\n\n### Not Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: checks if $A$ is not equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     \u003c\u003e []        // False\n[1, 2] \u003c\u003e [1, 2]    // False\n[1, 2] \u003c\u003e [1]       // True\n[1]    \u003c\u003e [1, 2]    // True\n[1, 2] \u003c\u003e [1, 3]    // True\n[1, 3] \u003c\u003e [1, 2]    // True\n```\n\n###  Less Than\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relational operations must be defined on $\\text{T}$.\n\n**Behavior**: checks if $A$ is less than $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     \u003c []      // False\n[1, 2] \u003c [1, 2]  // False\n[1, 2] \u003c [1]     // False\n[1]    \u003c [1, 2]  // True\n[1, 2] \u003c [1, 3]  // True\n[1, 3] \u003c [1, 2]  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relational operations must be defined on $\\text{T}$.\n\n**Behavior**: checks if $A$ is less than or equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     \u003c= []     // True\n[1, 2] \u003c= [1, 2] // True\n[1, 2] \u003c= [1]    // False\n[1]    \u003c= [1, 2] // True\n[1, 2] \u003c= [1, 3] // True\n[1, 3] \u003c= [1, 2] // False\n```\n\n### Greater Than\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relational operations must be defined on $\\textbf{T}$.\n\n**Behavior**: checks if $A$ is greater than $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     \u003e []      // False\n[1, 2] \u003e [1, 2]  // False\n[1, 2] \u003e [1]     // True\n[1]    \u003e [1, 2]  // False\n[1, 2] \u003e [1, 3]  // False\n[1, 3] \u003e [1, 2]  // True\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relational operations must be defined on $\\textbf{T}$.\n\n**Behavior**: checks if $A$ is greater than or equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n[]     \u003e= []      // True\n[1, 2] \u003e= [1, 2]  // True\n[1, 2] \u003e= [1]     // True\n[1]    \u003e= [1, 2]  // False\n[1, 2] \u003e= [1, 3]  // False\n[1, 3] \u003e= [1, 2]  // True\n```\n\n---\n\n## Basic functions\n\n### `length`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: returns number of elements in $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nlength [1, 2, 3]  // 3\nlength [1, 2]     // 2\nlength [1]        // 1\nlength []         // 0\n```\n\n### `flatten`\n\n**Signature** \n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[[\\textbf{T}]]$, and\n- $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: concatenates elements $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nflatten [[1], [2], [3]]  // [1, 2, 3]\nflatten [[1], [2, 3]]    // [1, 2, 3]\nflatten [[1, 2, 3]]      // [1, 2, 3]\nflatten []               // []\n```\n\n### `hd`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns the first element of $A$.\nResults in a run-time error if $A$ is empty.\n\n```\nhd of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nhd [1, 2, 3]  // 1\nhd [1, 2]     // 1\nhd [1]        // 1\nhd []         // NOT OK\n```\n\n### `tl`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: returns all except the first element of $A$.\nA run-time error will be thrown if $A$ is empty.\n\n```\ntl of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\ntl [1, 2, 3]  // [2, 3]\ntl [1, 2]     // [2]\ntl [1]        // []\ntl []         // NOT OK\n```\n\n### `last`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns the last element of $A$.\nResults in a run-time error if $A$ is empty.\n\n```\nlast of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nlast [1, 2, 3]  // 3\nlast [1, 2]     // 2\nlast [1]        // 1\nlast []         // NOT OK\n```\n\n### `init`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: returns all except the last element of $A$.\nResults in a run-time error if $A$ is empty.\n\n```\ninit of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\ninit [1, 2, 3]  // [1, 2]\ninit [1, 2]     // [1]\ninit [1]        // []\ninit []         // NOT OK\n```\n\n### `take`\n\n**Signature**\n\n$$\n\\begin{align*}\nn\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: returns the first $n$ elements of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\ntake 2 [1, 2, 3]  // [1, 2]\ntake 1 [1, 2]     // [1]\ntake 0 [1]        // []\ntake 0 []         // []\n```\n\n### `drop`\n\n**Signature**\n\n$$\n\\begin{align*}\nn\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: returns all but the first $n$ elements of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\ndrop 2 [1, 2, 3]  // [3]\ndrop 1 [1, 2]     // [2]\ndrop 1 [1]        // []\ndrop 0 []         // []\n```\n\n### `reverse`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: returns a reversed copy of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nreverse [1, 2, 3]  // [3, 2, 1]\nreverse [1, 2]     // [2, 1]\nreverse [1]        // [1]\nreverse []         // []\n```\n\n### `insertAt`\n\n**Signature**\n\n$$\n\\begin{align*}\ni\\rightarrow{a}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $i$ is of type $\\textbf{Int}$,\n- $a$ is of type $\\textbf{T}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: inserts $a$ into the $i$-th index of $A$.\nThe previous element is shifted to the right to make room.\n\n**Usage**\n\n```\n// Language: Clean\n\ninsertAt   2  9 [1, 2]  // [1, 2, 9]\ninsertAt   1  9 [1, 2]  // [1, 9, 2]\ninsertAt   0  9 [1, 2]  // [9, 1, 2]\ninsertAt (-1) 9 [1, 2]  // [1, 2, 9]\n```\n\n### `removeAt`\n\n**Signature**\n\n$$\n\\begin{align*}\ni\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $i$ is of type $\\textbf{Int}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: removes the element at $i$-th index of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nremoveAt   2  [1, 2]  // [1, 2]\nremoveAt   1  [1, 2]  // [1]\nremoveAt   0  [1, 2]  // [2]\nremoveAt (-1) [1, 2]  // [1,2]\n```\n\n### `updateAt`\n\n**Signature**\n\n$$\n\\begin{align*}\ni\\rightarrow{a}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $i$ is of type $\\textbf{Int}$,\n- $a$ is of type $\\textbf{T}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: replaces the element at $i$-th index of $A$ with $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nupdateAt   2  9 [1, 2]  // [1, 2]\nupdateAt   1  9 [1, 2]  // [1, 9]\nupdateAt   0  9 [1, 2]  // [9, 2]\nupdateAt (-1) 9 [1, 2]  // [1, 2]\n```\n\n### `splitAt`\n\n**Signature**\n\n$$\n\\begin{align*}\ni\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $i$ is of type $\\textbf{Int}$,\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $([\\textbf{T}], [\\textbf{T}])$.\n\n**Behavior**: splits $A$ into two at $i$-th index.\nThe element at $i$-th index goes to the second half.\n\n**Usage**\n\n```\n// Language: Clean\n\nsplitAt   2  [1, 2]  // ([1, 2], [])\nsplitAt   1  [1, 2]  // ([1], [2])\nsplitAt   0  [1, 2]  // ([], [1, 2])\nsplitAt (-1) [1, 2]  // ([1, 2], [])\n```\n\n### `indexList`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $[\\textbf{Int}]$.\n\n**Behavior**: generates a list of indexes from $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nindexList [3, 2, 1]  // [0, 1, 2]\nindexList [1, 2]     // [0, 1]\nindexList [2]        // [0]\nindexList []         // []\n```\n\n### `repeat`\n\n**Signature**\n\n$$\n\\begin{align*}\n{a}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{T}$, and\n- $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: generates an infinite list of the same element $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nrepeat 0     // [0, 0, 0, ...]\nrepeat 1.0   // [1.0, 1.0, 1.0, ...]\nrepeat 'a'   // ['a', 'a', 'a', ...] \nrepeat True  // [True, True, True, ...]\n```\n\n### `repeatn`\n\n**Signature** \n\n$$\n\\begin{align*}\n{n}\\rightarrow{a}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $n$ is of type $\\textbf{Int}$,\n- $a$ is of type $\\textbf{T}$, and\n- $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: generates a list of the same element $a$ with length of $n$.\n\n**Usage**\n\n```\n// Language: Clean\n\nrepeatn 0 0     // []\nrepeatn 1 1.0   // [1.0]\nrepeatn 2 'a'   // ['a', 'a'] \nrepeatn 3 True  // [True, True, True]\n```\n\n### `isMember`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $a$ is of type $\\textbf{T}$,\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: checks $a$ is a member of $A$ or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisMember 4 [1, 2, 3]  // False\nisMember 2 [1, 2, 3]  // True\nisMember 1 []         // False\n```\n\n### `isAnyMember`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$ and $B$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: returns true if any element of $B$ is also a element of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nisAnyMember [1, 2] [1, 2]  // True\nisAnyMember [1, 2] [3, 4]  // False\nisAnyMember [1, 2] []      // False\nisAnyMember [] [1, 2]      // False\n```\n\n### `removeDup`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: removes duplicate elements from $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nremoveDup [1, 2, 2, 3]  // [1, 2, 3]\nremoveDup [1, 2, 3, 4]  // [1, 2, 3, 4]\nremoveDup []            // []\n```\n\n### `removeMember`\n\n**Signature**\n\n$$\n\\begin{align*}\n{a}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $a$ is of type $\\textbf{T}$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: removes the first occurrence of $a$ from $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nremoveMember 4 [1, 2, 2, 3]  // [1, 2, 2, 3]\nremoveMember 2 [1, 2, 2, 3]  // [1, 2, 3]\nremoveMember 1 [1, 2, 2, 3]  // [2, 2, 3]\nremoveMember 0 []            // []\n```\n\n### `removeMembers`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$, $B$, and $R$ are of type $[\\textbf{T}]$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: removes the first occurrences of the elements of $B$ from $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nremoveMembers [1, 2, 3] []  // [1, 2, 3]\nremoveMembers [2, 3] [1]    // [2, 3]\nremoveMembers [1, 1] [1]    // [1]\nremoveMembers [] [1, 2]     // []\n```\n\n### `removeIndex`\n\n**Signature**\n\n$$\n\\begin{align*}\n{a}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $a$ is of type $\\textbf{T}$,\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $(\\textbf{Int}, [\\textbf{T}])$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$.\n\n**Behavior**: removes the first occurrence of $a$ from $A$ and returns the its index, as well as, the new list.\nResults in a run-time error if $a$ is not a member of $A$.\n\n```\nError in removeIndex: element not found\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nremoveIndex 2 [1, 2, 2, 3]  // (1, [1, 2, 3])\nremoveIndex 1 [1, 2, 2, 3]  // (0, [2, 2, 3])\nremoveIndex 4 [1, 2, 2, 3]  // NOT OK :(\n```\n\n### `sum`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\nAdditionally, addition and zero unit must be defined on $\\textbf{T}$.\n\n**Behavior**: returns sum of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nsum [1, 2, 3, 4]  // 10\nsum [1, 2, 3]     // 6\nsum [1, 2]        // 3\nsum [1]           // 1\n```\n\n### `prod`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\nAdditionally, multiplication and one unit must be defined on $\\textbf{T}$.\n\n**Behavior**: returns product of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nprod [1, 2, 3, 4]  // 24\nprod [1, 2, 3]     // 6\nprod [1, 2]        // 3\nprod [1]           // 1\n```\n\n### `avg`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\nAdditionally, addition, zero unit, and division must be defined on $\\textbf{T}$.\n\n**Behavior**: returns average $A$.\nResults in a run-time error if $A$ is empty.\n\n```\navg called with empty list\n```\n\n**Usage**\n\n```\n// Language: Clean\n\navg [1, 2, 3, 4]  // 2\navg [1, 2, 3]     // 2\navg [1, 2]        // 1\navg [1]           // 1\navg []            // NOT OK :(\n```\n\n### `and`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A_{b}}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A_{b}$ is of type $[\\textbf{Bool}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns true if and only if every element of $A_{b}$ is true.\n\n**Usage**\n\n```\n// Language: Clean\n\nand [False, False]  // False\nand [False, True]   // True\nand [True, True]    // True\nand [False]         // False\nand [True]          // True\nand []              // True\n```\n\n### `or`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A_{b}}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A_{b}$ and $R$ are of type $[\\textbf{Bool}]$, and\n- $R$ is of type $\\text{Bool}$.\n\n**Behavior**: returns false if and only if every element of $A_{b}$ is false.\n\n**Usage**\n\n```\n// Language: Clean\n\nor [False, False]  // False\nor [False, True]   // True\nor [True, True]    // True\nor [False]         // False\nor [True]          // True\nor []              // False\n```\n\n---\n\n## Higher-Order Functions\n\n### `takeWhile`\n\n**Signature** \n$$\n\\begin{align*}\nP\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{Bool})$, and\n- $A$ and $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: takes elements from the start of $A$ as long as $P$ is true.\n\n**Usage**\n\n```\n// Language: Clean\n\ntakeWhile isOdd  [1, 1, 1]  // [1, 1, 1]\ntakeWhile isOdd  [1, 2, 3]  // [1]\ntakeWhile isEven [1, 2, 3]  // []\ntakeWhile isOdd  []         // []\n```\n\n### `dropWhile`\n\n**Signature** \n$$\n\\begin{align*}\nP\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{Bool})$, and\n- $A$ and $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: discards elements from the start of $A$ as long as $P$ is true.\n\n**Usage**\n\n```\n// Language: Clean\n\ndropWhile isOdd  [1, 1, 1]  // []\ndropWhile isOdd  [1, 2, 3]  // [2, 3]\ndropWhile isEven [1, 2, 3]  // [1, 2, 3]\ndropWhile isOdd  []         // []\n```\n\n### `filter`\n\n**Signature** \n$$\n\\begin{align*}\nP\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{Bool})$, and\n- $A$ and $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: filters $A$ using $P$.\n\n**Usage**\n\n```\n// Language: Clean\n\nfilter isEven [2, 3, 4]  // [2, 4]\nfilter isEven [1, 2, 3]  // [2, 3]\nfilter isOdd  [1, 2, 3]  // [1]\nfilter isOdd  [2, 3, 4]  // [3]\nfilter isOdd  []         // []\n```\n\n### `foldr`\n\n**Signature** \n\n$$\n\\begin{align*}\nf\\rightarrow{k}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $f$ is of type $(\\textbf{T}\\rightarrow\\textbf{K}\\rightarrow\\textbf{K})$, \n- $k$ and $R$ are of type $\\textbf{K}$, and\n- $A$ is of type $[\\textbf{T}]$.\n\n**Behavior**: folds $A$ using a right-associative operation $f$.\n\n**Usage**\n\n```\n// Language: Clean\n\nfoldr (+) 0 [1, 2, 3]\n// 1 + (2 + (3 + 0))\n// 6\n\nfoldr (+) 0 [3, 2, 1]\n// 3 + (2 + (1 + 0))\n// 6\n\nfoldr (^) 1 [1, 2, 3]\n// 1 ^ (2 ^ (3 ^ 1))\n// 1\n\nfoldr (^) 1 [3, 2, 1]\n// 3 ^ (2 ^ (1 ^ 1))\n// 9\n```\n\n### `foldl`\n\n**Signature** \n\n$$\n\\begin{align*}\nf\\rightarrow{t}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $f$ is of type $(\\textbf{T}\\rightarrow\\textbf{K}\\rightarrow\\textbf{T})$, \n- $t$ is of type $\\textbf{T}$,\n- $A$ is of type $[\\textbf{K}]$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: folds $A$ using a left-associative operation $f$.\n\n**Usage**\n\n```\n// Language: Clean\n\nfoldl (+) 0 [1, 2, 3]\n// ((0 + 1) + 2) + 3\n// 6\n\nfoldr (+) 0 [3, 2, 1]\n// ((0 + 3) + 2) + 1\n// 6\n\nfoldl (^) 1 [1, 2, 3]\n// ((1 ^ 1) ^ 2) ^ 3\n// 1\n\nfoldl (^) 1 [3, 2, 1]\n// ((1 ^ 3) ^ 2)  ^ 1\n// 1\n```\n\n### `iterate`\n\n**Signature** \n\n$$\n\\begin{align*}\nf\\rightarrow{a}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $f$ is of type $(\\textbf{T}\\rightarrow\\textbf{T})$,\n- $a$ is of type $\\textbf{T}$, and\n- $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: generates an infinite list by repeatedly apply $f$ to $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\niterate ((+) 1) 0  // [0, 1, 2, ...]\niterate ((*) 2) 1  // [1, 2, 4, ...]\niterate toInt   1  // [1, 1, 1, ...]\n```\n\n### `map`\n\n**Signature** \n\n$$\n\\begin{align*}\nf\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $f$ is of type $\\textbf{T}\\rightarrow\\textbf{K}$,\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $[\\textbf{K}]$.\n\n**Behavior**: applies $f$ to every element of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nmap isEven  [1, 2, 3]  // [False, True, False]\nmap toReal  [1, 2, 3]  // [1.0, 2.0, 3.0]\nmap ((+) 2) [1, 2, 3]  // [3, 4, 5]\n```\n\n### `scan`\n\n**Signature** \n\n$$\n\\begin{align*}\nf\\rightarrow{a}\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $f$ is of type $(\\textbf{T}\\rightarrow\\textbf{K}\\rightarrow\\textbf{T})$, \n- $a$ is of type $\\textbf{T}$,\n- $B$ is of type $[\\textbf{K}]$, and\n- $R$ is of type $[\\textbf{T}]$.\n\n**Behavior**: generates a list of reduced values from apply $f$ to $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nscan (+) 0 [1, 2, 3]\n// [0, 0 + 1, (0 + 1) + 2, ((0 + 1) + 2) + 3]\n// [0, 1, 3, 6]\n\nscan (+) 0 [3, 2, 1]\n// [0, 0 + 3, (0 + 3) + 2, ((0 + 3) + 2) + 1]\n// [0, 3, 5, 6]\n\nscan (^) 1 [1, 2, 3]\n// [1, 1 ^ 1, (1 ^ 1) ^ 2, ((1 ^ 1) ^ 2) ^ 3]\n// [1, 1, 1, 1]\n\nscan (^) 1 [3, 2, 1]\n// [1, 1 ^ 3, (1 ^ 3) ^ 2, ((1 ^ 3) ^ 2) ^ 1]\n// [1, 1, 1, 1]\n```\n\n### `any`\n\n**Signature** \n\n$$\n\\begin{align*}\nP\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{Bool})$, \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns false if and only if $P$ does not hold for any element of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nany isEven [1, 2, 3]  // True\nany isOdd  [1, 2, 3]  // True\nany isEven [1, 3, 5]  // False\nany isOdd  [2, 4, 6]  // False\nany isEven []         // False\nany isOdd  []         // False\n```\n\n### `all`\n\n**Signature** \n\n$$\n\\begin{align*}\nP\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{Bool})$, \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns true if and only if $P$ holds for every element of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n\nall isEven [1, 2, 3]  // False\nall isOdd  [1, 2, 3]  // False\nall isEven [2, 4, 6]  // True\nall isOdd  [1, 3, 5]  // True\nall isEven []         // True\nall isOdd  []         // True\n```\n\n---\n\n## Property Functions\n\n### `isEmpty`\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is empty or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisEmpty []   // True\nisEmpty [1]  // False\n```\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdordlist":{"title":"Appendix A: StdOrdList","content":"\n## Basic Functions\n\n### `sort`\n\n**Signature** \n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\nAdditionally, equality and relational operations must be defined on $\\textbf{T}$.\n\n**Behavior**: sorts $A$ in ascending order using Merge Sort.\n\n**Usage**\n\n```\n// Language: Clean\n\nsort [1, 1, 1]  // [1, 1, 1]\nsort [1, 2, 3]  // [1, 2, 3]\nsort [2, 1, 3]  // [1, 2, 3]\nsort []         // []\n```\n\n### `maxList`\n\n**Signature** \n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\nAdditionally, equality and relational operations must be defined on $\\textbf{T}$.\n\n**Behavior**: returns the biggest element of $A$.\nResults in a run-time error if $A$ is empty.\n\n```\nmaxList of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nmaxList [1, 1, 1]  // 1\nmaxList [1, 2, 3]  // 3\nmaxList []         // NOT OK :(\n```\n\n### `minList`\n\n**Signature**\n\n$$\n\\begin{align*}\n{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\nAdditionally, equality and relational operations must be defined on $\\textbf{T}$.\n\n**Behavior**: returns the smallest element of $A$.\nResults in a run-time error if $A$ is empty.\n\n```\nminList of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nminList [1, 1, 1]  // 1\nminList [1, 2, 3]  // 1\nminList []         // NOT OK :(\n```\n\n---\n\n## Higher-Order Functions\n\n### `sortBy`\n\n**Signature** \n\n$$\n\\begin{align*}\n{P}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{T}\\rightarrow\\textbf{Bool})$, and\n- $A$ and $R$ are of type $[\\textbf{T}]$.\n\n**Behavior**: sorts $A$ using an ordering function $P$.\n\n**Usage**\n\n```\n// Language: Clean\n\nsortBy (\u003e) [1, 1, 1]  // [1, 1, 1]\nsortBy (\u003e) [1, 2, 3]  // [3, 2, 1]\nsortBy (\u003e) [2, 1, 3]  // [3, 2, 1]\nsortby (\u003e) []         // []\n```\n\n### `maxListBy`\n\n**Signature**\n\n$$\n\\begin{align*}\n{P}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{T}\\rightarrow\\textbf{Bool})$, \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns the biggest element of $A$ using an ordering function $P$.\nResults in a run-time error if $A$ is empty.\n\n```\nmaxListBy of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nmaxListBy (\u003c) [1, 2, 3]  // 3\nmaxListBy (\u003e) [1, 1, 1]  // 1\nmaxListBy (\u003e) [1, 2, 3]  // 1\nmaxListBy (\u003e) []         // NOT OK :(\n```\n\n### `minListBy`\n\n**Signature** \n\n$$\n\\begin{align*}\n{P}\\rightarrow{A}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $P$ is of type $(\\textbf{T}\\rightarrow\\textbf{T}\\rightarrow\\textbf{Bool})$, \n- $A$ is of type $[\\textbf{T}]$, and\n- $R$ is of type $\\textbf{T}$.\n\n**Behavior**: returns the smallest element of $A$ using an ordering function $P$.\nA run-time error will be thrown if $A$ is empty.\n\n```\nminListBy of []\n```\n\n**Usage**\n\n```\n// Language: Clean\n\nminListBy (\u003c) [1, 2, 3]  // 1\nminListBy (\u003e) [1, 1, 1]  // 1\nminListBy (\u003e) [1, 2, 3]  // 3\nminListBy (\u003e) []         // NOT OK :(\n```\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdoverloaded":{"title":"Appendix A: StdOverloaded","content":"\n## Operations\n\n### Addition\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: adds $a$ and $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass + T\nwhere:\n    (+) infixl 6 :: T T -\u003e T\n```\n\n### Subtraction\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: subtracts $b$ from $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass + T\nwhere:\n    (-) infixl 6 :: T T -\u003e T\n```\n\n### Multiplication\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: multiplies $a$ and $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass * T\nwhere:\n    (*) infixl 7 :: T T -\u003e T\n```\n\n### Division\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{a}\\rightarrow{a}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is a generic type.\n\n**Behavior**: divides $a$ with $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass / T\nwhere:\n    (/) infixl 7 :: T T -\u003e T\n```\n\n### Exponentiation\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: raises $a$ to the power of $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass ^ T\nwhere:\n    (^) infixl 7 :: T T -\u003e T\n```\n\n### Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: checks if $a$ and $b$ are equal.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass == T\nwhere:\n    (==) infixl 4 :: T T -\u003e T\n```\n\n### Less Than\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: checks if $a$ is less than $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass \u003c T\nwhere:\n    (\u003c) infixl 4 :: T T -\u003e T\n```\n\n### Slicing\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow(i,\\ j)\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type, and\n- $i$ and $j$ are of type $\\textbf{Int}$.\n\n**Behavior**: slices $[i,\\ j]$ interval from $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass % T\nwhere:\n    (%) infixl 9 :: T (Int, Int) -\u003e T\n```\n\n### Concatenation\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: joins $a$ and $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass +++ T\nwhere:\n    (+++) infixl 5 :: T T -\u003e T\n```\n\n### Modulo\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: $a\\mod{b}$\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass mod T\nwhere:\n    (mod) infixl 7 :: T T -\u003e T\n```\n\n### Reminder Of Division\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type.\n\n**Behavior**: reminder after dividing $a$ with $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass rem T\nwhere:\n    (rem) infixl 7 :: T T -\u003e T\n```\n\n### Negate\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type.\n\n**Behavior**: negates $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass ~ T\nwhere:\n    ~ :: T -\u003e T\n```\n\n---\n\n## Units\n\n### Zero Unit\n\n**Behavior**: unit element for addition.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass zero T\nwhere:\n    zero :: T\n```\n\n### One Unit\n\n**Behavior**: unit element for multiplication.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass one T\nwhere:\n    one :: T\n```\n\n---\n\n## Functions\n\n### `inc`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type.\n\n**Behavior**: adds $a$ by its one unit.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass inc T\nwhere:\n    inc :: T -\u003e T\n```\n\n### `dec`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type.\n\n**Behavior**: subtracts $a$ by its one unit.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass dec T\nwhere:\n    dec :: T -\u003e T\n```\n\n### `abs`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type.\n\n**Behavior**: returns absolute value of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass abs T\nwhere:\n    abs :: T -\u003e T\n```\n\n### `sign`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of a generic type, and\n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: returns sign of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass sign T\nwhere:\n    sign :: T -\u003e Int\n```\n\n### `isEven`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of a generic type, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns true if and only if $a$ is even.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass isEven T\nwhere:\n    isEven :: T -\u003e Bool\n```\n\n### `isOdd`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of a generic type, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: returns true if and only if $a$ is odd.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass isOdd T\nwhere:\n    isOdd :: T -\u003e Bool\n```\n\n### `length`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of a generic type, and\n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: returns length of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass length T\nwhere:\n    length :: (T a) -\u003e Bool\n```\n\n### `gcd`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type. \n\n**Behavior**: returns greatest common divisor of $a$ and $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass gcd T\nwhere:\n    gcd :: T T -\u003e T\n```\n\n### `lcm`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, and $R$ are of a generic type. \n\n**Behavior**: returns least common multiple of $a$ and $b$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass lcm T\nwhere:\n    lcm :: T T -\u003e T\n```\n\n### `ln`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns natural log of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass ln T\nwhere:\n    ln :: T -\u003e T\n```\n\n### `log10`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns logarithm base $10$ of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass log10 T\nwhere:\n    log10 :: T -\u003e T\n```\n\n### `exp`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns $e$ raise to the power of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass exp T\nwhere:\n    exp :: T -\u003e T\n```\n\n### `sqrt`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns square root of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass sqrt T\nwhere:\n    sqrt :: T -\u003e T\n```\n\n### `sin`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns sine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass sin T\nwhere:\n    sin :: T -\u003e T\n```\n\n### `cos`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns cosine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass cos T\nwhere:\n    cos :: T -\u003e T\n```\n\n### `tan`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns tangent of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass tan T\nwhere:\n    tan :: T -\u003e T\n```\n\n### `asin`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of sine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass asin T\nwhere:\n    asin :: T -\u003e T\n```\n\n### `acos`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of cosine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass acos T\nwhere:\n    acos :: T -\u003e T\n```\n\n### `atan`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of tangent of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass sin T\nwhere:\n    sin :: T -\u003e T\n```\n\n### `sinh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns hyperbolic sine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass sinh T\nwhere:\n    sinh :: T -\u003e T\n```\n\n### `cosh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns hyperbolic cosine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass cosh T\nwhere:\n    cosh :: T -\u003e T\n```\n\n### `tanh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns hyperbolic tangent of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass tanh T\nwhere:\n    tanh :: T -\u003e T\n```\n\n### `asinh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of hyperbolic sine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass asinh T\nwhere:\n    asinh :: T -\u003e T\n```\n\n### `acosh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of hyperbolic cosine of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass acosh T\nwhere:\n    acosh :: T -\u003e T\n```\n\n### `atanh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of a generic type. \n\n**Behavior**: returns inverse of hyperbolic tangent of $a$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass atanh T\nwhere:\n    atanh :: T -\u003e T\n```\n\n---\n\n## Conversion Functions\n\n### `toInt`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n-  $a$ is of a generic type, and \n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: converts $a$ to $\\textbf{Int}$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass toInt T\nwhere:\n    toInt :: T -\u003e Int\n```\n\n### `toReal`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n-  $a$ is of a generic type, and \n- $R$ is of type $\\textbf{Real}$.\n\n**Behavior**: converts $a$ to $\\textbf{Real}$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass toReal T\nwhere:\n    toReal :: T -\u003e Real\n```\n\n### `toChar`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n-  $a$ is of a generic type, and \n- $R$ is of type $\\textbf{Char}$.\n\n**Behavior**: converts $a$ to $\\textbf{Char}$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass toChar T\nwhere:\n    toChar :: T -\u003e Char\n```\n\n### `toBool`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n-  $a$ is of a generic type, and \n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: converts $a$ to $\\textbf{Bool}$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass toBool T\nwhere:\n    toBool :: T -\u003e Bool\n```\n\n### `toString`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of a generic type, and \n- $R$ is of type $\\textbf{String}$.\n\n**Behavior**: converts $a$ to $\\textbf{String}$.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass toString T\nwhere:\n    toString :: T -\u003e String\n```\n\n### `fromInt`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Int}$, and\n- $R$ is of a generic type.\n\n**Behavior**: converts an integer $a$ to a generic type.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass fromInt T\nwhere:\n    fromInt :: Int -\u003e T\n```\n\n### `fromReal`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Real}$, and\n- $R$ is of a generic type.\n\n**Behavior**: converts a real number $a$ to a generic type.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass fromReal T\nwhere:\n    fromReal :: Real -\u003e T\n```\n\n### `fromChar`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Char}$, and\n- $a$ is of a generic type.\n\n**Behavior**: converts a character $a$ to a generic type.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass fromChar T\nwhere:\n    fromChar :: Char -\u003e T\n```\n\n### `fromBool`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Bool}$, and\n-  $R$ is of a generic type.\n\n**Behavior**: converts a Boolean $a$ to a generic type.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass fromBool T\nwhere:\n    fromBool :: Bool -\u003e T\n```\n\n### `fromString`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{String}$, and\n- $R$ is of a generic type. \n\n**Behavior**: converts a string $a$ to a generic type.\n\n**Declaration**\n\n```\n// Language: Clean\n\nclass fromString T\nwhere:\n    fromString :: String -\u003e T\n```\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdreal":{"title":"Appendix A: StdReal","content":"\n## Arithmetic Operations\n\n### Negation\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: inverts the sign of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\n~  1.0   // -1.0\n~  0.0   //  0.0\n~(-1.0)  //  1.0\n```\n\n### Addition\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: adds $a$ and $b$ together.\n\n**Usage**\n\n```\n// Language: Clean\n\n  2.5  +   1.5   //  4.0\n  2.5  + (-1.5)  //  1.5\n(-2.5) +   1.5   // -1.0\n(-2.5) + (-1.5)  // -4.0\n```\n\n### Subtraction\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: subtracts $b$ from $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  2.5  -   1.5   //  1.0\n  2.5  - (-1.5)  //  4.0\n(-2.5) -   1.5   // -1.5\n(-2.5) - (-1.5)  // -1.0\n```\n\n### Multiplication\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: multiplies $a$ with $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  2.5  *   1.5   //  3.75\n  2.5  * (-1.5)  // -3.75\n(-2.5) *   1.5   // -3.75\n(-2.5) * (-1.5)  //  3.75\n```\n\n### Division\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: divides $a$ with $b$. \n\n**Usage**\n\n```\n// Language: Clean\n\n  2.5  /   1.5   //  1.66666666666667\n  2.5  / (-1.5)  // -1.66666666666667\n(-2.5) /   1.5   // -1.66666666666667\n(-2.5) / (-1.5)  //  1.66666666666667\n  1.0  /   0.0   //  #INF\n(-1.0) /   0.0   // -#INF\n```\n\n### Exponentiation\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$, $b$, $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: raises $a$ to the $b$-th power.\n\n**Usage**\n\n```\n// Language: Clean\n\n  2.5  ^   1.5   //  3.95284707521047\n  2.5  ^ (-1.5)  //  0.25298221281347\n(-2.5) ^   1.5   //  #NAN\n(-2.5) ^ (-1.5)  //  #NAN\n  0.0  ^   0.0   //  1.0\n  0.0  ^   1.0   //  0.0\n  0.0  ^ (-1.0)  //  #INF\n```\n\n---\n\n## Relational Operations\n\n### Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Real}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  ==   2.0   // False\n(-5.0) ==   2.0   // False\n  5.0  == (-2.0)  // False\n(-5.0) == (-2.0)  // False\n(-2.0) == (-2.0)  // True\n```\n\n### Not Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Real}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is not equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  \u003c\u003e   2.0   // True\n(-5.0) \u003c\u003e   2.0   // True\n  5.0  \u003c\u003e (-2.0)  // True\n(-5.0) \u003c\u003e (-2.0)  // True\n(-2.0) \u003c\u003e (-2.0)  // False\n```\n\n### Less Than\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Real}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is less than $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  \u003c   2.0   // False\n(-5.0) \u003c   2.0   // True\n  5.0  \u003c (-2.0)  // False\n(-5.0) \u003c (-2.0)  // True\n(-2.0) \u003c (-2.0)  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Real}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is less than or equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  \u003c=   2.0   // False\n(-5.0) \u003c=   2.0   // True\n  5.0  \u003c= (-2.0)  // False\n(-5.0) \u003c= (-2.0)  // True\n(-2.0) \u003c= (-2.0)  // True\n```\n\n### Greater Than\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Real}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is greater than $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  \u003e   2.0   // True\n(-5.0) \u003e   2.0   // False\n  5.0  \u003e (-2.0)  // True\n(-5.0) \u003e (-2.0)  // False\n(-2.0) \u003e (-2.0)  // False\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{b}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $b$ are of type $\\textbf{Real}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is greater than or equal to $b$.\n\n**Usage**\n\n```\n// Language: Clean\n\n  5.0  \u003e=   2.0   // True\n(-5.0) \u003e=   2.0   // False\n  5.0  \u003e= (-2.0)  // True\n(-5.0) \u003e= (-2.0)  // False\n(-2.0) \u003e= (-2.0)  // True\n```\n\n---\n\n## Basic Functions\n\n### `sign`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns sign of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nsign   1.0   //  1\nsign   0.0   //  0\nsign (-1.0)  // -1\n```\n\n### `abs`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns absolute value of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nabs   1.0   //  1.0\nabs   0.0   //  0.0\nabs (-1.0)  // 1.0\n```\n\n### `entier`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Real}$, and\n- $R$ is of type $\\textbf{Int}$.\n\n**Behavior**: returns floor of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nentier   1.5   //  1\nentier   0.0   //  0\nentier (-1.5)  // -2\n```\n\n### `ln`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns natural logarithm of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nln   2.5   //  0.916290731874155\nln   1.5   // -1.405465108108164\nln   0.0   // -#INF\nln (-1.5)  //  #NAN\nln (-2.5)  //  #NAN\n```\n### `log10`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns logarithm base $10$ of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nlog10   2.5   //  0.397940008672038\nlog10   1.5   // -0.176091259055681\nlog10   0.0   // -#INF\nlog10 (-1.5)  //  #NAN\nlog10 (-2.5)  //  #NAN\n```\n\n### `exp`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: raises $e$ to $a$-th power.\n\n**Usage**\n\n```\n// Language: Clean\n\nexp   2.5   // 12.1824939607035\nexp   1.5   //  4.48168907033806\nexp   0.0   //  1.0\nexp (-1.5)  //  0.22313016014843\nexp (-2.5)  //  0.0820849986238988\n```\n\n### `sqrt`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns square root of $a$.\n\n**Usage**\n\n```\n// Language: Clean\n\nsqrt   2.5   // 1.58113883008419\nsqrt   1.5   // 1.22474487139159\nsqrt   0.0   // 0.0\nsqrt (-1.5)  // #NAN\nsqrt (-2.5)  // #NAN\n```\n\n---\n\n## Trigonometric Functions\n\n### `sin`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns $\\sin(a)$ .\n\n**Usage**\n\n```\n// Language: Clean\n\nsin   2.5   //  0.598472144103956\nsin   1.5   //  0.997494986604054\nsin   0.0   //  0.0\nsin (-1.5)  // -0.997494986604054\nsin (-2.5)  // -0.598472144103956\n```\n\n### `cos`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns $\\cos(a)$.\n\n**Usage**\n\n```\n// Language: Clean\n\ncos   2.5   // -0.801143615546934\ncos   1.5   //  0.0707372016677029\ncos   0.0   //  1.0\ncos (-1.5)  //  0.0707372016677029\ncos (-2.5)  // -0.801143615546934\n```\n\n### `tan`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns $\\tan(a)$.\n\n**Usage**\n\n```\n// Language: Clean\n\ntan   2.5   // - 0.74702229723866\ntan   1.5   //  14.1014199471717\ntan   0.0   //   0.0\ntan (-1.5)  // -14.1014199471717\ntan (-2.5)  //   0.74702229723866\n```\n\n### `asin`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns ${\\sin}^{-1}(a)$.\nThe domain is in interval $[-1,1]$.\n\n**Usage**\n\n```\n// Language: Clean\n\nasin   2.5   //  #NAN\nasin   1.5   //  #NAN\nasin   0.5   //  0.523598775598299\nasin   0.0   //  0.0\nasin (-0.5)  // -0.523598775598299\nasin (-1.5)  //  #NAN\nasin (-2.5)  //  #NAN\n```\n\n### `acos`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns ${\\cos}^{-1}(a)$.\nThe domain is in interval $[-1,1]$.\n\n**Usage**\n\n```\n// Language: Clean\n\nacos   2.5   // #NAN\nacos   1.5   // #NAN\nacos   0.5   // 1.0471975511966\nacos   0.0   // 1.5707963267949\nacos (-0.5)  // 2.0943951023932\nacos (-1.5)  // #NAN\nacos (-2.5)  // #NAN\n```\n\n### `atan`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns ${\\tan}^{-1}(a)$.\n\n**Usage**\n\n```\n// Language: Clean\n\nacos   2.5   //  1.19028994968253\nacos   1.5   //  0.982793723247329\nacos   0.5   //  0.463647609000806\nacos   0.0   //  0.0\nacos (-0.5)  // -0.463647609000806\nacos (-1.5)  // -0.982793723247329\nacos (-2.5)  // -1.19028994968253\n```\n\n### `sinh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns $\\sinh(a)$.\n\n**Usage**\n\n```\n// Language: Clean\n\nsinh   2.5   //  6.05020448103979\nsinh   1.5   //  2.12927945509482\nsinh   0.5   //  0.521095305493747\nsinh   0.0   //  0.0\nsinh (-0.5)  // -0.521095305493747\nsinh (-1.5)  // -2.12927945509482\nsinh (-2.5)  // -6.05020448103979\n```\n\n### `cosh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns $\\cosh(a)$.\n\n**Usage**\n\n```\n// Language: Clean\n\ncosh   2.5   //  6.13228947966369\ncosh   1.5   //  2.35240961524325\ncosh   0.5   //  1.12762596520638\ncosh   0.0   //  1.0\ncosh (-0.5)  // -1.12762596520638\ncosh (-1.5)  // -2.35240961524325\ncosh (-2.5)  // -6.13228947966369\n```\n\n### `tanh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns $\\tanh(a)$.\n\n**Usage**\n\n```\n// Language: Clean\n\ntanh   2.5   //  0.98661429815143\ntanh   1.5   //  0.905148253644866\ntanh   0.5   //  0.46211715726001\ntanh   0.0   //  0.0\ntanh (-0.5)  // -0.46211715726001\ntanh (-1.5)  // -0.905148253644866\ntanh (-2.5)  // -0.98661429815143\n```\n\n### `asinh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns ${\\sinh}^{-1}(a)$.\n\n**Usage**\n\n```\n// Language: Clean\n\nasinh   2.5   //  1.6472311463711\nasinh   1.5   //  1.19476321728711\nasinh   0.5   //  0.481211825059604\nasinh   0.0   //  0.0\nasinh (-0.5)  // -0.481211825059604\nasinh (-1.5)  // -1.19476321728711\nasinh (-2.5)  // -1.6472311463711\n```\n\n### `acosh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns ${\\cosh}^{-1}(a)$.\n\n**Usage**\n\n```\n// Language: Clean\n\ncosh   2.5   // 1.56679923697241\ncosh   1.5   // 0.962423650119207\ncosh   0.5   // #NAN\ncosh   0.0   // #NAN\ncosh (-0.5)  // #NAN\ncosh (-1.5)  // #NAN\ncosh (-2.5)  // #NAN\n```\n\n### `atanh`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ and $R$ are of type $\\textbf{Real}$.\n\n**Behavior**: returns ${\\tanh}^{-1}(a)$.\n\n**Usage**\n\n```\n// Language: Clean\n\natanh   2.5   //  #NAN\natanh   1.5   //  #NAN\natanh   0.5   //  0.549306144334055\natanh   0.0   //  0.0\natanh (-0.5)  // -0.549306144334055\natanh (-1.5)  //  #NAN\natanh (-2.5)  //  #NAN\n```\n\n---\n\n## Property Functions\n\n### `isNaN`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Real}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is $\\text{NaN}$ or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisNaN  2.0               // False\nisNaN  0.0               // False\nisNaN (sqrt (-1.0))      // True\nisNaN (ln   (-1.0))      // True\nisNaN ((-1.0) /   0.0)   // False\nisNaN (  0.0  ^ (-1.0))  // False\n```\n\n### `isInfinity`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Real}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is an infinite representation or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisInfinity 2.0                // False\nisInfinity 0.0                // False\nisInfinity (sqrt (-1.0))      // False\nisInfinity (ln   (-1.0))      // False\nisInfinity ((-1.0) /   0.0)   // True\nisInfinity (  0.0  ^ (-1.0))  // True\n```\n\n### `isFinite`\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\textbf{Real}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $a$ is finite or not.\n\n**Usage**\n\n```\n// Language: Clean\n\nisFinite 2.0                // True\nisFinite 0.0                // True\nisFinite (sqrt (-1.0))      // False\nisFinite (ln   (-1.0))      // False\nisFinite ((-1.0) /   0.0)   // False\nisFinite (  0.0  ^ (-1.0))  // False\n```\n\n---\n\n\n## Conversions To Real Numbers\n\n### Integers To Real Numbers\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\text{Int}$, and\n- $R$ is of type $\\textbf{Real}$.\n\n**Behavior**: converts $a$ to a real number.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoReal   2   //  2.0\ntoReal   1   //  1.0\ntoReal   0   //  0.0\ntoReal (-1)  // -1.0\ntoReal (-2)  // -2.0\n```\n\n### Strings To Real Numbers\n\n**Signature**\n\n$$\n\\begin{align*}\na\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $a$ is of type $\\text{String}$, and\n- $R$ is of type $\\textbf{Real}$.\n\n**Behavior**: converts $a$ to an real number.\n\n**Usage**\n\n```\n// Language: Clean\n\ntoReal \"1.0\"   //  1.0\ntoReal \"1\"     //  1.0\ntoReal \"0\"     //  0.0\ntoReal \"-1\"    // -1.0\ntoReal \"-1.0\"  //  1.0\n```\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdstring":{"title":"Appendix A: StdString","content":"\n## Basic Operations \n\n### Concatenation\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere \n- $A$, $B$, and $R$ are of type $\\textbf{String}$.\n\n**Behavior**: joins$B$ to the end of $A$.\n\n**Usage**\n\n```\n// Language: Clean\n \n\"123\" +++ \"45\"  // \"12345\"\n\"123\" +++ \"4\"   // \"1234\"\n\"123\" +++ \"\"    // \"123\"\n```\n\n### Slicing\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow(i, j)\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A, R$ are of type $\\textbf{String}$, and\n- $i, j$ are of type $\\textbf{Int}$.\n\n**Behavior**: returns elements of $A$ which are inside $[i, j]$ interval.\n\n**Usage**\n\n```\n// Language: Clean\n \n\"123\" % (  2,  4)  // \"3\"\n\"123\" % (  0,  2)  // \"123\"\n\"123\" % ((-1), 0)  // \"12\"\n\"123\" % ((-2), 5)  // \"123\"\n```\n\n### Update\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow(i,\\ a)\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere :\n- $A$ and $R$ are of type $\\textbf{String}$,\n- $i$ is of type $\\textbf{Int}$, and\n- $a$ is of type $\\textbf{Char}$.\n\n**Behavior**: updates element at $i$-th index of $A$ with $a$.\nResults in a run-time error if $i$ is not a valid index.\n\n```\nIndex too high in UPDATE string.\n\n```\n\n**Usage**\n\n```\n// Language: Clean\n \n\"abcde\" := (  5,  'X')  // NOT OK :(\n\"abcde\" := (  2,  'C')  // \"abCde\"\n\"abcde\" := (  0,  'A')  // \"Abcde\"\n\"abcde\" := ((-1), 'A')  // NOT OK :(\n```\n\n---\n\n## Relational Operations\n\n### Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n\"\"   == \"\"    // True\n\"12\" == \"12\"  // True\n\"12\" == \"1\"   // False\n\"1\"  == \"12\"  // False\n\"12\" == \"13\"  // False\n\"13\" == \"12\"  // False\n```\n\n### Not Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is not equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n\"\"   \u003c\u003e \"\"    // False\n\"12\" \u003c\u003e \"12\"  // False\n\"12\" \u003c\u003e \"1\"   // True\n\"1\"  \u003c\u003e \"12\"  // True\n\"12\" \u003c\u003e \"13\"  // True\n\"13\" \u003c\u003e \"12\"  // True\n```\n\n### Less Than\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is less than $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n\"\"   \u003c \"\"    // False\n\"12\" \u003c \"12\"  // False\n\"12\" \u003c \"1\"   // False\n\"1\"  \u003c \"12\"  // True\n\"12\" \u003c \"13\"  // True\n\"13\" \u003c \"12\"  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is less than or equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n\"\"   \u003c= \"\"    // True\n\"12\" \u003c= \"12\"  // True\n\"12\" \u003c= \"1\"   // False\n\"1\"  \u003c= \"12\"  // True\n\"12\" \u003c= \"13\"  // True\n\"13\" \u003c= \"12\"  // False\n```\n\n### Greater Than\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is greater than $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n\"\"   \u003e \"\"    // False\n\"12\" \u003e \"12\"  // False\n\"12\" \u003e \"1\"   // True\n\"1\"  \u003e \"12\"  // False\n\"12\" \u003e \"13\"  // False\n\"13\" \u003e \"12\"  // True\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\nA\\rightarrow{B}\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $A$ and $B$ are of type $\\textbf{String}$, and\n- $R$ is of type $\\textbf{Bool}$.\n\n**Behavior**: checks if $A$ is greater than or equal to $B$.\n\n**Usage**\n\n```\n// Language: Clean\n\n// Language: Clean\n\n\"\"   \u003e= \"\"    // True\n\"12\" \u003e= \"12\"  // True\n\"12\" \u003e= \"1\"   // True\n\"1\"  \u003e= \"12\"  // False\n\"12\" \u003e= \"13\"  // False\n\"13\" \u003e= \"12\"  // True\n```\n\n[Back to top](#)\n\n---\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-a/stdtuple":{"title":"Appendix A: StdTuple","content":"\n## Relational Operations\n\n### Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if two tuples are equal or not.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx == Ty) \u0026\u0026 (Kx == Ky)  // for 2-tuples\n\n(Tx == Ty) \u0026\u0026 (Kx == Ky) \u0026\u0026 (Vx == Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') == (1, 'a')  // True\n(1, 'a') == (1, 'b')  // False\n(1, 'a') == (1, 'b')  // False\n(2, 'a') == (1, 'a')  // False\n```\n\n### Not Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, equality operation must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if two tuples are not equal or not.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx \u003c\u003e Ty) \u0026\u0026 (Kx \u003c\u003e Ky)  // for 2-tuples\n\n(Tx \u003c\u003e Ty) \u0026\u0026 (Kx \u003c\u003e Ky) \u0026\u0026 (Vx \u003c\u003e Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') \u003c\u003e (1, 'a')  // False\n(1, 'a') \u003c\u003e (1, 'b')  // False\n(1, 'a') \u003c\u003e (1, 'b')  // False\n(2, 'a') \u003c\u003e (1, 'a')  // False\n```\n\n### Less Than\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relation operations must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if one tuple is less than another tuple.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx \u003c Ty) \u0026\u0026 (Kx \u003c Ky)  // for 2-tuples\n\n(Tx \u003c Ty) \u0026\u0026 (Kx \u003c Ky) \u0026\u0026 (Vx \u003c Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') \u003c (1, 'a')  // False\n(1, 'a') \u003c (1, 'b')  // False\n(1, 'a') \u003c (1, 'b')  // False\n(2, 'a') \u003c (1, 'a')  // False\n```\n\n### Less Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relation operations must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if one tuple is less than or equal to another tuple.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx \u003c= Ty) \u0026\u0026 (Kx \u003c= Ky)  // for 2-tuples\n\n(Tx \u003c= Ty) \u0026\u0026 (Kx \u003c= Ky) \u0026\u0026 (Vx \u003c= Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') \u003c= (1, 'a')  // True\n(1, 'a') \u003c= (1, 'b')  // True\n(1, 'a') \u003c= (1, 'b')  // True\n(2, 'a') \u003c= (1, 'a')  // False\n```\n\n### Greater Than\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relation operations must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if one tuple is greater than another tuple.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx \u003e Ty) \u0026\u0026 (Kx \u003e Ky)  // for 2-tuples\n\n(Tx \u003e Ty) \u0026\u0026 (Kx \u003e Ky) \u0026\u0026 (Vx \u003e Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') \u003e (1, 'a')  // True\n(1, 'a') \u003e (1, 'b')  // True\n(1, 'a') \u003e (1, 'b')  // True\n(2, 'a') \u003e (1, 'a')  // False\n```\n\n### Greater Than Or Equal To\n\n**Signature**\n\n$$\n\\begin{align*}\n(\\textbf{T}, \\textbf{K})\\rightarrow(\\textbf{T}, \\textbf{K})\\rightarrow{R}\n\\end{align*}\n$$\n\nor\n\n$$\n\\begin{align*}\n(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow(\\textbf{T},\\textbf{K},\\textbf{V})\\rightarrow{R}\n\\end{align*}\n$$\n\nwhere:\n- $R$ is of type $\\textbf{Bool}$.\n\nAdditionally, relation operations must be defined on $\\textbf{T}$, $\\textbf{K}$, and $\\textbf{V}$.\n\n**Behavior**: checks if one tuple is greater than or equal to another tuple.\nInternally, this is equivalent to the following.\n\n```\n// Language: Clean\n\n(Tx \u003e= Ty) \u0026\u0026 (Kx \u003e= Ky)  // for 2-tuples\n\n(Tx \u003e= Ty) \u0026\u0026 (Kx \u003e= Ky) \u0026\u0026 (Vx \u003e= Vy)  // for 3-tuples\n```\n\n**Usage**\n\n```\n// Language: Clean\n\n(1, 'a') \u003e= (1, 'a')  // False\n(1, 'a') \u003e= (1, 'b')  // False\n(1, 'a') \u003e= (1, 'b')  // False\n(2, 'a') \u003e= (1, 'a')  // True\n```\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null},"/appendix-b":{"title":"Appendix B: Code recipes","content":"\n## Table of contents\n\n- [Introduction](#introduction)\n- [Breaking an integer into its digits](#breaking-an-integer-into-its-digits)\n- [Computing divisors of an integer](#computing-divisors-of-an-integer)\n- [Checking if an integer is prime or not](#checking-if-an-integer-is-prime-or-not)\n\n## Introduction\n\nThis section contains a collection of common and useful functions.\nEach method includes the implementation as well as the explanation.\n\n## Breaking an integer into digits\n\n**Signature** \n\n$$\n\\begin{align*}\n\\text{Int}\\rightarrow[\\text{Int}]\n\\end{align*}\n$$\n\n**Expected result**\n\n```\n// Language: Clean\n\ntoDigits 123  // [1, 2, 3]\ntoDigits 456  // [4, 5, 6]\ntoDigits 1234 // [1, 2, 3, 4]\ntoDigits 4567 // [4, 5, 6, 7]\n```\n\n### Recursion\n\n**Implementation**:\n\n```\n// Language: Clean\n\ntoDigits :: Int -\u003e [Int]\ntoDigits    n \n| (abs n) \u003c 10  =  [n]\n| otherwise     =  (toDigits (n / 10)) ++ [n rem 10]\n```\n\n**Conversion pathway**\n\n$$\n\\begin{align*}\n\\text{Int}\\rightarrow\\text{[Int]}\n\\end{align*}\n$$\n\n**Explanation**:\n\nGiven an integer $n$, the last digit is placed on the end of a list.\nTo get the last digit of $n$, we take advantage of the $\\text{mod}$ operation. \n\nBefore the next iteration, $n$ is divided by $10$, this step removes the last digit of $n$ since it has already been placed in the list.\n\n$\\text{abs}$ expands domain from $[0,\\ \\infty)$ to $(-\\infty,\\ \\infty)$.\n\n### List comprehension\n\n```\n// Language: Clean\n\ntoDigits :: Int -\u003e [Int]\ntoDigits    n   =  [(toInt d) - 48 \\\\ d \u003c-: (toString n)]\n```\n\n**Conversion  pathway**\n\n$$\n\\begin{align*}\n\\text{Int}\\rightarrow\\text{String}\\rightarrow\\text{Char}\\rightarrow\\text{Int}\\rightarrow[\\text{Int}]\n\\end{align*}\n$$\n\n**Explanation**:\n\nSince arrays can be freely converted to lists and vice versa, we can convert $n$ to an array.\n\nIn this case, $n$ is converted into an array of $\\text{Char}$.\n$\\text{toInt}$ then converts each digit of $n$ to $\\text{Int}$.\n\nHowever, the $\\text{Char}\\rightarrow\\text{Int}$ conversions are ASCII based.\nThat is \n- character $1$ converts to integer value $49$, \n- character $2$ converts to integer value $50$, and so on.\n\nIn the final step, an offset value of $48$ is subtracted from the result.\n\n\n[Back to top](#)\n\n---\n\n## Computing divisors of an integer\n\n**Signature**: $\\text{Int}\\rightarrow\\text{[Int]}$\n\n**Expected result**:\n\n```\n// Language: Clean\n\ndivisorsOf 9  // [1, 3, 9]\ndivisorsOf 16 // [1, 2, 4, 8, 16]\ndivisorsOf 2  // [1, 2]\ndivisorsOf 0  // [0]\n```\n\n### List comprehension\n\n```\n// Language: Clean\n\nisDivisible :: Int Int -\u003e Bool\nisDivisible    x   y   =  (x rem y) == 0\n\ndivisorsOf :: Int -\u003e [Int]\ndivisorsOf    0   =  [0]\ndivisorsOf    n   =  [d \\\\ d \u003c- [1..(abs n)] | isDivisible n d]\n```\n\n**Conversions**\n\n$$\n\\text{Int}\\rightarrow[\\text{Int}]\n$$\n\n**Explanation**:\n\nA list of integers is generated.\nIt contains integers in $[1,\\ \\lvert{n}\\rvert]$ interval.\n\nThe helper function $\\text{isDivisible}$ determines which integer will be placed in the list, and which integer will be discarded.\n\nIf an integer $d$ is a divisor of $n$, it is included in the list.\nIf it does not full divide $n$, it is discarded.\n\n[Back to top](#)\n\n---\n\n## Checking if an integer is prime\n\n**Signature**: $\\text{Int} \\rightarrow\\text{Bool}$\n\n**Expected result**:\n\n```\n// Language: Clean\n\nisPrime 9 // False\nisPrime 3 // True\nisPrime 1 // False\nisPrime 0 // False\n```\n\n### Counting divisors list (comprehension)\n\n```\n// Language: Clean\n\nisPrime :: Int -\u003e Bool\nisPrime 0 = False\nisPrime 1 = False\nisPrime n = length (filter isDivisorOfN [d \\\\ d \u003c- ds]) == 0\nwhere\n\tds :: [Int]\n\tds =  [2..(n - 1)]\n\n\tisDivisorOfN :: Int -\u003e Bool\n\tisDivisorOfN k = (n rem k) == 0\n```\n\n**Conversions**: $\\text{Int}\\rightarrow\\text{[Int]}\\rightarrow\\text{Int}\\rightarrow\\text{Bool}$\n\n**Explanation**:\n\nFor $n \\gt 1$, a list of integers from $2$ to $n - 1$ is constructed.\nThe list filtered to only contain divisors of $n$.\n\nIf the divisor list is empty, $n$ is a prime number.\n\n### Using list of booleans\n\n```\nisPrime :: Int -\u003e Bool\nisPrime 0 = False\nisPrime 1 = False\nisPrime n = not (or [n rem d == 0 \\\\ d \u003c- [2..(n - 1)]]) \n```\n\n**Conversions**: $\\text{Int}\\rightarrow\\text{[Int]}\\rightarrow\\text{[Bool]}\\rightarrow\\text{Bool}$\n\n[Back to top](#)\n\n---\n","lastmodified":"2023-05-28T14:32:10.100234608Z","tags":null}}