{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Notes on CLEAN (programming language)","text":""},{"location":"#notes-on-syntax-and-semantics","title":"Notes on syntax and semantics","text":"<ul> <li>Predefined data types</li> </ul>"},{"location":"#notes-on-practical-usage","title":"Notes on practical usage","text":"<ul> <li>The Standard Environment module</li> <li>CLEAN puzzles</li> </ul>"},{"location":"puzzles/","title":"Puzzles","text":"<p>A collection of CLEAN code snippets for common questions and problems.</p>"},{"location":"puzzles/#break-an-integer-into-its-digits","title":"Break an integer into its digits","text":"<p>Problem</p> <p>Given an integer \\(n\\), how can we obtain each individual digit of it?</p> <p>Expected result</p> <pre><code>// CLEAN\n\ntoDigits 123   // [1, 2, 3]\ntoDigits 456   // [4, 5, 6]\ntoDigits 1234  // [1, 2, 3, 4]\ntoDigits 4567  // [4, 5, 6, 7]\n</code></pre>"},{"location":"puzzles/#using-recursion","title":"Using recursion","text":"<p>Solution</p> <pre><code>// CLEAN\n\ntoDigits :: Int -&gt; [Int]\ntoDigits    n \n| (abs n) &lt; 10  =  [n]\n| otherwise     =  (toDigits (n / 10)) ++ [n rem 10]\n</code></pre> <p>Explanation:</p> <p>This approach takes advantage of the reminder division operation. Before the next iteration, \\(n\\) is divided by \\(10\\), this step removes the last digit of \\(n\\) since it has already been placed in the list.</p> <p>The abs expands domain of our function from \\([0,\\ \\infty)\\) to \\((-\\infty,\\ \\infty)\\).</p>"},{"location":"puzzles/#list-comprehension","title":"List comprehension","text":"<pre><code>// CLEAN\n\ntoDigits :: Int -&gt; [Int]\ntoDigits    n   =  [(toInt d) - 48 \\\\ d &lt;-: (toString n)]\n</code></pre> <p>Explanation</p> <p>Since arrays can be freely converted to lists and vice versa, we can convert \\(n\\) to an array.</p> <p>In this case, \\(n\\) is converted into an array of \\(\\text{Char}\\). \\(\\text{toInt}\\) then converts each digit of \\(n\\) to \\(\\text{Int}\\).</p> <p>However, the \\(\\text{Char}\\rightarrow\\text{Int}\\) conversions are ASCII based. That is  - character \\(1\\) converts to integer value \\(49\\),  - character \\(2\\) converts to integer value \\(50\\), and so on.</p> <p>In the final step, an offset value of \\(48\\) is subtracted from the result.</p>"},{"location":"puzzles/#computing-divisors-of-an-integer","title":"Computing divisors of an integer","text":"<p>Expected result</p> <pre><code>// CLEAN\n\ndivisorsOf 9  // [1, 3, 9]\ndivisorsOf 16 // [1, 2, 4, 8, 16]\ndivisorsOf 2  // [1, 2]\ndivisorsOf 0  // [0]\n</code></pre>"},{"location":"puzzles/#list-comprehension_1","title":"List comprehension","text":"<pre><code>// CLEAN\n\nisDivisible :: Int Int -&gt; Bool\nisDivisible    x   y   =  (x rem y) == 0\n\ndivisorsOf :: Int -&gt; [Int]\ndivisorsOf    0   =  [0]\ndivisorsOf    n   =  [d \\\\ d &lt;- [1..(abs n)] | isDivisible n d]\n</code></pre> <p>Explanation:</p> <p>A list of integers is generated. It contains integers in \\([1,\\ \\lvert{n}\\rvert]\\) interval.</p> <p>The helper function \\(\\text{isDivisible}\\) determines which integer will be placed in the list, and which integer will be discarded.</p> <p>If an integer \\(d\\) is a divisor of \\(n\\), it is included in the list. If it does not full divide \\(n\\), it is discarded.</p>"},{"location":"puzzles/#checking-if-an-integer-is-prime","title":"Checking if an integer is prime","text":"<p>Expected result:</p> <pre><code>// CLEAN\n\nisPrime 9 // False\nisPrime 3 // True\nisPrime 1 // False\nisPrime 0 // False\n</code></pre>"},{"location":"puzzles/#counting-divisors-list-comprehension","title":"Counting divisors list (comprehension)","text":"<pre><code>// CLEAN\n\nisPrime :: Int -&gt; Bool\nisPrime 0 = False\nisPrime 1 = False\nisPrime n = length (filter isDivisorOfN [d \\\\ d &lt;- ds]) == 0\nwhere\n    ds :: [Int]\n    ds =  [2..(n - 1)]\n\n    isDivisorOfN :: Int -&gt; Bool\n    isDivisorOfN k = (n rem k) == 0\n</code></pre> <p>Explanation:</p> <p>For \\(n \\gt 1\\), a list of integers from \\(2\\) to \\(n - 1\\) is constructed. The list filtered to only contain divisors of \\(n\\).</p> <p>If the divisor list is empty, \\(n\\) is a prime number.</p>"},{"location":"puzzles/#using-list-of-booleans","title":"Using list of booleans","text":"<pre><code>// CLEAN\n\nisPrime :: Int -&gt; Bool\nisPrime 0 = False\nisPrime 1 = False\nisPrime n = not (or [n rem d == 0 \\\\ d &lt;- [2..(n - 1)]]) \n</code></pre>"},{"location":"predefined-data-types/","title":"Predefined data types","text":"<p>Notes on primitive data types:</p> <ul> <li>boolean-type</li> <li>character-type</li> <li>PDT P Integer Type</li> <li>PDT P Real Number Type</li> </ul> <p>Notes on structured data types:</p> <ul> <li>PDT S Array Type</li> <li>PDT S Arrow Type</li> <li>PDT S List Type</li> <li>PDT S Tuple Type</li> </ul>"},{"location":"predefined-data-types/PDT%20P%20Integer%20Type/","title":"Integer Type","text":"<p>Integers are represented using 32 bits or 64 bits values.</p> <p>For built-in functions and operations on integer type, see stdint.</p>"},{"location":"predefined-data-types/PDT%20P%20Integer%20Type/#integer-type-declaration","title":"Integer Type Declaration","text":"<p>Integer type is explicitly declared with <code>Int</code>.</p> <pre><code>// Language: Clean\n\nexpr :: Int\nexpr =  1 + 1\n</code></pre>"},{"location":"predefined-data-types/PDT%20P%20Integer%20Type/#integer-literals","title":"Integer Literals","text":"<p>They can be constructed from decimal notation.</p> <pre><code>// Language: Clean\n\nx :: Int\nx = -13\nx =  0\nx =  13\n</code></pre> <p>They can be constructed from octal notation by prefixing octal digits with <code>0</code>.</p> <pre><code>// Language: Clean\n\nx :: Int\nx = -015  // decimal -13\nx =  00   // decimal  0\nx =  015  // decimal  13\n</code></pre> <p>And they can be constructed from hexadecimal notation by prefixing hexadecimal digits with <code>0x</code>.</p> <pre><code>// Language: Clean\n\nx :: Int\nx = -0xD  // decimal -13\nx =  0x0  // decimal  0\nx =  0xd  // decimal  13\n</code></pre> <p>%%## Integer Pattern in Functions</p>"},{"location":"predefined-data-types/PDT%20P%20Integer%20Type/#example-a","title":"Example A","text":"<pre><code>// Language: Clean\n\nexampleA :: Int -&gt; Bool\nexampleA    1   =  True\nexampleA    _   =  False\n</code></pre> <p>The <code>exampleA</code> function has two equivalent variants.</p> <p>One variant is obtained by using octal notation instead of decimal notation.</p> <pre><code>// Language: Clean\n\nexampleA :: Int -&gt; Bool\nexampleA    01  =  True\nexampleA    _   =  False\n</code></pre> <p>And another variant is obtained by using hexadecimal notation.</p> <pre><code>// Language: Clean\n\nexampleA :: Int -&gt; Bool\nexampleA    0x1 =  True\nexampleA    _   =  False\n</code></pre> <p>Python equivalent:</p> <pre><code># Python\n\ndef exampleA(n: int) -&gt; bool\n    match n:\n        case 1:\n            return True\n        case _:\n            return False\n</code></pre>"},{"location":"predefined-data-types/PDT%20P%20Integer%20Type/#example-b","title":"Example B","text":"<pre><code>// Language: Clean\n\nexampleB :: Int Int -&gt; Int\nexampleB    x   0   =  x\nexampleB    0   y   =  y\nexampleB    x   y   =  x + y\n</code></pre> <p>The <code>exampleB</code> function has many equivalent variants.</p> <p>A variant is obtained by using octal notation.</p> <pre><code>// Language: Clean\n\nexampleB :: Int Int -&gt; Int\nexampleB    x   00  =  x\nexampleB    00  y   =  y\nexampleB    x   y   =  x + y\n</code></pre> <p>A variant is obtained by using hexadecimal notation.</p> <pre><code>// Language: Clean\n\nexampleB :: Int Int -&gt; Int\nexampleB    x   0x0 =  x\nexampleB    0x0 y   =  y\nexampleB    x   y   =  x + y\n</code></pre> <p>A variant is obtained by mixing octal notation and hexadecimal notation.</p> <pre><code>// Language: Clean\n\nexampleB :: Int Int -&gt; Int\nexampleB    x   00  =  x\nexampleB    0x0 y   =  y\nexampleB    x   y   =  x + y\n</code></pre> <p>Python equivalent:</p> <pre><code># Python\n\ndef exampleB(\n    n: int,\n    m: int\n) -&gt; int:\n    match (n, m):\n    case (_, 0):\n            return n\n        case (0, _):\n            return m\n        case _:\n            return n + m\n</code></pre>"},{"location":"predefined-data-types/PDT%20P%20Integer%20Type/#integer-pattern-in-comprehensions","title":"Integer Pattern in Comprehensions","text":"<p>When an integer literal is used on the left side of a generator, it evokes a pattern matching behavior.</p> <pre><code>// Language: Clean\n\nexample :: [ Int ]\nexample =  [ 9 \\\\ 1 &lt;- [ 1, 2, 3 ] ]\n</code></pre> <p>The extracted elements must match the integer literal. Otherwise, the iteration is skipped.</p> <p>Python equivalent: </p> <pre><code># Python\n\nexample: list[int] = []\nfor e in [1, 2, 3]:\n    match e:\n        case 1:\n            pass\n        case _:\n            continue\n    example.append(9)\n</code></pre> <p>The same effect is achieved with PDT S Comprehensions#Example E Conditional Iteration, but logical operations must be defined on the type, which is the benefit of this method.</p> <p>```Clean // Language: Clean</p> <p>example :: [ Int ] example =  [ 9 \\ x &lt;- [ 1, 2, 3 ] | x == 1 ] ```%%</p>"},{"location":"predefined-data-types/PDT%20P%20Real%20Number%20Type/","title":"Real Number Type","text":"<p>Real numbers are represented by 64 bits values.</p> <p>For built-in functions and operations on real number type, see stdreal module.</p>"},{"location":"predefined-data-types/PDT%20P%20Real%20Number%20Type/#real-number-type-declaration","title":"Real Number Type Declaration","text":"<p>Real number type is explicitly declared with <code>Real</code>.</p> <pre><code>// Language: Clean\n\nexpr :: Real\nexpr =  1.0 + 1.0\n</code></pre>"},{"location":"predefined-data-types/PDT%20P%20Real%20Number%20Type/#real-number-literals","title":"Real Number Literals","text":"<p>They can be constructed from decimal notation.</p> <pre><code>// Language: Clean\n\nx :: Real\nx = -1.3\nx =  0.0\nx =  1.3\n</code></pre> <p>And they can be constructed from scientific notation.</p> <pre><code>// Language: Clean\n\nx :: Real\nx = -1.3E-2  // -0.13\nx =  0E1     //  0\nx =  1.3E-2  //  0.13\n</code></pre> <p>Only upper case \"E\" can be used in scientific notations. The expression results in a compile-time error if lower case \"e\" is used.</p> <pre><code>// Language: Clean\n\ny :: Real\ny =  13e-2  // compile-time error\n</code></pre> <p>%%</p>"},{"location":"predefined-data-types/PDT%20P%20Real%20Number%20Type/#using-real-number-literal-as-pattern","title":"Using Real Number Literal as Pattern","text":"<p>Example A:</p> <pre><code>// Language: Clean\n\nexampleA :: Real -&gt; Bool\nexampleA    1.0  =  True\nexampleA    _    =  False\n</code></pre> <p>The <code>exampleA</code> function returns <code>True</code> when it is called with 1. Otherwise, it returns <code>False</code>.</p> <p>It has many equivalent variants.</p> <p>One variant is obtained by using scientific notation instead of decimal notation.</p> <pre><code>// Language: Clean\n\nisUnit :: Real -&gt; Bool\nisUnit    1E1  =  True\nisUnit    _    =  False\n</code></pre> <p>Example B:</p> <pre><code>// Language: Clean\n\nexampleB :: Real Real -&gt; Real\nexampleB    x    0.0  =  x\nexampleB    0.0  y    =  y\nexampleB    x    y    =  x + y\n</code></pre> <p>The <code>exampleB</code> function performs real number addition. If one of its argument is 0, it returns the other argument.</p> <p>It has many equivalent variants.</p> <p>One variant is obtained by using scientific notation instead of decimal notation.</p> <pre><code>// Language: Clean\n\nexampleB :: Real Real -&gt; Real\nexampleB    x    1E1  =  x\nexampleB    1E1  y    =  y\nexampleB    x    y    =  x + y\n</code></pre> <p>A variant can be obtained by mixing decimal notation and scientific notation.</p> <p><pre><code>// Language: Clean\n\nexampleB :: Real Real -&gt; Real\nexampleB    x    0.0  =  x\nexampleB    1E1  y    =  y\nexampleB    x    y    =  x + y\n</code></pre> %%</p>"},{"location":"predefined-data-types/PDT%20S%20Array%20Type/","title":"Array Type","text":""},{"location":"predefined-data-types/PDT%20S%20Arrow%20Type/","title":"PDT S Arrow Type","text":""},{"location":"predefined-data-types/PDT%20S%20Comprehensions/","title":"Comprehensions","text":"<p>They provide an alternative way to implicitly construct lists and arrays, but they cannot be used as a pattern.</p> <p>While it is possible to construct every types of list or array with comprehension, for simplicity, they are used to construct lazy lists.</p> <p>Comprehensions iterate over a generator, which is an existing list or array. In each iteration, the left-most element is extracted from the generator. Its value is stored in a selector.</p>"},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#usage-examples","title":"Usage Examples","text":""},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#extracting-elements-from-generators","title":"Extracting Elements From Generators","text":"<p>Each generator requires a unique \"arrow\" to extract elements.</p> <p>A left arrow (<code>&lt;-</code>) is used to extract elements from list generators, except overloaded list generators.</p> <pre><code>// Language: Clean\n\nlistA ::  [ T ]\nlistA = [ e \\\\ e &lt;- lsGen ]\n</code></pre> <p>A left arrow with vertical bar between the arrowhead and the shaft (<code>&lt;|-</code>) is used to extract elements from overloaded list generators.</p> <pre><code>// Language: Clean\n\nlistA :: [ T ]\nlistA =  [ e \\\\ e &lt;|- overloadedLsGen ]\n</code></pre> <p>A left arrow with colon at the end (<code>&lt;-:</code>) is used to extract elements from array generators.</p> <pre><code>// Language: Clean\n\nlistA :: [ T ]\nlistA =  [ e \\\\ e &lt;-: arrGen ]\n</code></pre> <p>Python equivalent:</p> <pre><code># Language: Python\n\nlistA: list[any] = []\nfor e in lsGen:\n    listA.append(e)\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#nesting-generators","title":"Nesting Generators","text":"<p>Commas (<code>,</code>) are used to join generators by nesting them. The right-most generator is the fastest.</p> <pre><code>// Language: Clean\n\nlistB :: [ ( T, K ) ]\nlistB =  [ ( eX, eY ) \\\\ \n    eX &lt;- lsGenX , \n    eY &lt;- lsGenY \n]\n</code></pre> <p>Python equivalent:</p> <pre><code># Language: Python\n\nlistB: list[tuple[any, any]] = []\nfor eX in lsGenX:\n    for eY in lsGenY:\n        listB.append( (eX, eY) )\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#zipping-generators","title":"Zipping Generators","text":"<p>Ampersands (<code>&amp;</code>) are used to join generators by zipping them. Iteration stops as soon as one generator runs out of element.</p> <pre><code>// Language: Clean\n\nlistC :: [ ( T, K ) ]\nlistC =  [ ( eX, eY ) \\\\ \n    eX &lt;- lsGenX &amp; \n    eY &lt;- lsGenY\n]\n</code></pre> <p>Python equivalent:</p> <pre><code># Language: Python\n\nlistC: list[tuple[any, any]] = []\nfor eX, eY in zip(lsGenX, lsGenY):\n    listC.append( (eX, eY) )\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#nesting-and-zipping-generators","title":"Nesting and Zipping Generators","text":"<p>Commas (<code>,</code>) and ampersands (<code>&amp;</code>) can be used together to join generators. Ampersands bind more tightly than commas when joining generators.</p>"},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#example-1","title":"Example 1","text":"<pre><code>// Langauge: Clean\n\nlistDa :: [ ( T, K, V ) ]\nlistDa =  [ ( eX, eY, eZ ) \\\\ \n    eX &lt;- lsGenX &amp; \n    eY &lt;- lsGenY , \n    eZ &lt;- lsGenZ\n]\n</code></pre> <p>Python equivalent:</p> <pre><code># Language: Python\n\nlistDa: list[tuple[any, any, any]] = []\nfor eX, eY in zip(lsGenX, lsGenY):\n    for eZ in lsGenZ:\n        listDa.append( (eX, eY, eZ) )\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#example-2","title":"Example 2","text":"<pre><code>// Langauge: Clean\n\nlistDb :: [ ( T, K, V ) ]\nlistDb =  [ ( eX, eY, eZ ) \\\\ \n    eX &lt;- lsGenX , \n    eY &lt;- lsGenY &amp; \n    eZ &lt;- lsGenZ \n]\n</code></pre> <p>Python equivalent:</p> <pre><code># Language: Python\n\nlistDb: list[tuple[any, any, any]] = []\nfor eX in lsGenX:\n    for eY, eZ in zip(lsGenY, lsGenZ):\n        listDb.append( (eX, eY, eZ) )\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#conditional-iteration","title":"Conditional Iteration","text":"<p>A condition can be introduced after each generator. When the condition fails, the current iteration is skipped.</p> <pre><code>// Langauge: Clean\n\nlistE :: [ T ]\nlistE =  [ e \\\\ e &lt;- lsGen | pred e ]\n</code></pre> <p>Python equivalent:</p> <pre><code># Language: Python\n\nlistE: list[any] = []\nfor e in lsGen:\n    if not pred(e):\n        continue\n    listE.append(e)\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#conditional-iteration-in-nested-generators","title":"Conditional Iteration in Nested Generators","text":"<p>Each nested generator can have its own condition.</p> <p>Example 1:</p> <pre><code>// Langauge: Clean\n\nx :: [ ( T, K ) ]\nx =  [ ( eX, eY ) \\\\ \n    eX &lt;- lsGenX | predX eX , \n    eY &lt;- lsGenY | predY eY\n]\n</code></pre> <p>Python equivalent:</p> <pre><code># Language: Python\n\nx: list[tuple[any, any]] = []\nfor eX in lsGenX:\n    if not predX(eX):\n        continue\n    for eY in lsGenY:\n        if not predY(eY):\n            continue\n        x.append((eX, eY))\n</code></pre> <p>Example 2:</p> <pre><code>// Langauge: Clean\n\nx :: [ ( T, K ) ]\nx =  [ ( eX, eY ) \\\\ \n    eX &lt;- lsGenX | predX eX , \n    eY &lt;- lsGenY | predY eX eY\n]\n</code></pre> <p>Python equivalent:</p> <pre><code># Language: Python`\n\nx: list[tuple[any, any]] = []\nfor eX in lsGenX:\n    if not predX(eX):\n        continue\n    for eY in lsGenY:\n        if not predY(eX, eY):\n            continue\n        x.append((eX, eY))\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#conditional-iteration-in-zipped-generators","title":"Conditional Iteration in Zipped Generators","text":"<p>A group of zipped generators can only have a condition.</p> <p>Example 1:</p> <pre><code>// Langauge: Clean\n\nx :: [ ( T, K ) ]\nx =  [ ( eX, eY ) \\\\ \n    eX &lt;- lsGenX &amp; \n    eY &lt;- lsGenY | pred eX \n]\n</code></pre> <p>Python equivalent:</p> <pre><code># Language: Python\n\nx: list[tuple[any, any]] = []\nfor eX, Ey in zip(lsGenX, lsGenY):\n    if not predY(eX):\n        continue\n    x.append((eX, eY))\n</code></pre> <p>Example 2:</p> <pre><code>// Langauge: Clean\n\nx :: [ ( T, K ) ]\nx =  [ ( eX, eY ) \\\\ \n    eX &lt;- lsGenX &amp; \n    eY &lt;- lsGenY | pred eX eY\n]\n</code></pre> <p>Python equivalent:</p> <pre><code># Language: Python\n\nx: list[tuple[any, any]] = []\nfor eX, eY in zip(lsGenX, lsGenY):\n    if not predY(eX, eY):\n        continue\n    x.append((eX, eY))\n</code></pre> <p>Example 3:</p> <pre><code>// Langauge: Clean\n\nx :: [ ( T, K ) ]\nx =  [ ( eX, eY ) \\\\ \n    eW &lt;- lsGenW &amp; \n    eX &lt;- lsGenX | predWX eW eX ,\n    eY &lt;- lsGenY &amp;\n    eZ &lt;- lsGenZ | predYZ eY eZ\n]\n</code></pre> <p>Python equivalent:</p> <pre><code># Language: Python\n\nx: list[tuple[any, any]] = []\nfor eW, eX in zip(lsGenW, lsGenX):\n    if not predWX(eW, eX):\n        continue\n    for eW, eX in zip(lsGenW, lsGenX):\n        if not predYZ(eY, eZ):\n            continue\n        x.append((eX, eY))\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#additional-usage-examples","title":"Additional Usage Examples","text":""},{"location":"predefined-data-types/PDT%20S%20Comprehensions/#conversion-between-list-and-array","title":"Conversion Between List and Array","text":"<p>Conversion between a lazy list and a lazy array can be done with comprehension.</p> <p>Example 1:</p> <pre><code>// Language: Clean\n\nxList :: [ T ]\nxList =  [ e \\\\ e &lt;-: xArr ] \n</code></pre> <p>Example 2:</p> <pre><code>// Language: Clean\n\nxArr :: { T }\nxArr =  { e \\\\ e &lt;- xList } \n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20List%20Type%20Dot-Dot%20Expressions/","title":"Dot-Dot Expressions","text":"<p>They require <code>StdEnum</code> module from the Standard Environment and provide an alternative way to implicitly construct lists. They cannot be used as a pattern.</p> <p>All type of lists can be constructed using Dot-Dot expressions, but the element type must be an instance of <code>Enum</code> class.</p> <p>The full syntax has three components, but only the first component is mandatory.</p> <pre><code>// Language: Clean\n\n[ init, next .. last ]\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20List%20Type%20Dot-Dot%20Expressions/#usage-examples","title":"Usage Examples","text":"<p>If only <code>init</code> component is given, it evaluates to an infinite list. Consecutive elements differ by one unit.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 1 .. ]  // [ 1, 2, 3 and so on ]\n</code></pre> <p>If <code>init</code> and <code>last</code> components are given, it evaluates to a finite list. Consecutive elements differ by one unit.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 1 .. 4 ]  // [ 1, 2, 3, 4 ] \n</code></pre> <p>If <code>init</code> and <code>next</code> components are given, it evaluates to an infinite list. Consecutive elements differ by <code>next</code> minus <code>init</code> unit.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 1, 3 .. ]  // [ 1, 3, 5 and so on ]\n</code></pre> <p>It is possible to construct an infinite list whose elements are in descending order.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 1, 0 .. ]  // [ 1, 0, -1 and so on ]\n</code></pre> <p>If <code>init</code>, <code>next</code>, and <code>last</code> components are given, it evaluates to a finite list. Consecutive elements differ by <code>next</code> minus <code>init</code> unit.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 1, 3 ..7 ]  // [ 1, 3, 5, 7 ]\n</code></pre> <p>If the difference is positive, elements strictly greater than <code>last</code> are not included.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 1, 3 .. 6 ]  // [ 1, 3, 5 ]\n</code></pre> <p>When <code>last</code> is greater than <code>init</code> but lesser than <code>next</code>, only <code>init</code> is included.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 1, 3 .. 2 ]  // [ 1 ]\n</code></pre> <p>When <code>last</code> is lesser than both <code>init</code> and <code>next</code>, no element is included.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 1, 3 .. 0 ]  // [ ]\n</code></pre> <p>If the difference is negative, elements strictly less than <code>last</code> are not included.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 4, 2 .. -3 ]  // [ 4, 2, 0, -2 ]\n</code></pre> <p>When <code>last</code> is greater than <code>next</code> but lesser than <code>init</code>, only <code>init</code> is included.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 3, 1 .. 2 ]  // [ 3 ]\n</code></pre> <p>When <code>last</code> is greater than both <code>next</code> and <code>init</code>, no element is included.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 3, 1 .. 4 ]  // [ ]\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20List%20Type/","title":"List Type","text":"<p>Lists can contain an infinite number of elements.  Elements of a list must be of the same type. </p> <p>For built-in functions and operations on list, see stdlist, stdcharlist, and stdordlist module for additional information.</p>"},{"location":"predefined-data-types/PDT%20S%20List%20Type/#list-type-declaration","title":"List Type Declaration","text":"<p>Lazy list is explicitly declared by placing the element type inside a pair of square brackets (<code>[ ... ]</code>).</p> <pre><code>// Language: Clean\n\nexpr :: [ Int ]\nexpr =  [ 1, 2, 3 ]\n</code></pre> <p>List type can be placed in front of element type.</p> <pre><code>// Language: Clean\n\nexpr :: [ ] Int\nexpr =  [ 1, 2, 3 ]\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20List%20Type/#list-literals","title":"List Literals","text":"<p>They are the explicit enumeration of elements, and can be used as patterns.</p> <p>Commas (<code>,</code>) are used to separate each element of a list.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 1, 2, 3 ]\n</code></pre> <p>Colons (<code>:</code>) act as right-associate pseudo-operator in list construction. They accept two arguments, which are an element on its left and a list on its right. They evaluate by prepending the element to the front of the list, and return a new list.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 1 : 2 : 3 : [] ]\nx =  [ 1 : [ 2 : [ 3 : [] ] ] ]\n</code></pre> <p>Commas and colons can be used together.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 1 : [ 2, 3 ] ]\nx =  [ 1, 2 : [ 3 ] ]\n</code></pre> <p>A special constructor is provided for lists of characters.</p> <p>By placing multiple characters inside a pair of single quotation marks (<code>' ... '</code>), each character is treated as an element of the list.</p> <pre><code>// Language: Clean\n\nxc :: [ Char ]\nxc =  [ 'a', 'b', 'c' ]\nxc =  [ 'abc' ]\n</code></pre> <p>Commas can be used with this special notation.</p> <pre><code>// Language: Clean\n\nxc :: [ Char ]\nxc =  [ 'a', 'bc' ]\n</code></pre>"},{"location":"predefined-data-types/PDT%20S%20List%20Type/#implicit-list-construction","title":"Implicit List Construction","text":"<p>Lists can be implicitly constructed, but they cannot be used as patterns.</p> <p>Colons can be used to construct lists from existing ones.</p> <pre><code>// Language: Clean\n\nx :: [ Int ]\nx =  [ 2, 3 ]\n\ny :: [ Int ]\ny =  [ 1 : x ]\n</code></pre> <p>Dot-Dot expressions construct lists from enumerable data types, see PDT S List Type Dot-Dot Expressions.</p> <p>And comprehensions construct list using from generators, see PDT S Comprehensions.</p>"},{"location":"predefined-data-types/PDT%20S%20List%20Type/#additional-list-types","title":"Additional List Types","text":"<p>So far only lazy lists are discussed, but other types of lists are: - head strict,  - tail strict,  - strict,  - unboxed head strict, - unboxed strict, and  - overloaded.</p> <p>They are considered different type with unique time and space properties.</p> <p>Functions defined on one type of list cannot be applied to others. However, a function defined on overloaded list can be applied to any type of list.</p> <p>Head strict lists are explicitly declared by placing an exclamation mark (<code>!</code>) after the opening square bracket (<code>[! ... ]</code>).</p> <pre><code>// Language: Clean\n\nx :: [! Int ]\nx =  [! 1, 2, 3 ]\n</code></pre> <p>Tail strict lists are explicitly declared by placing an exclamation mark (<code>!</code>) before the closing square bracket (<code>[ ... !]</code>).</p> <pre><code>// Language: Clean\n\nx :: [ Int !] \nx =  [ 1, 2, 3 !]\n</code></pre> <p>Strict lists are explicitly declared by placing an exclamation mark (<code>!</code>) after and before the square bracket (<code>[! ... !]</code>).</p> <pre><code>// Language: Clean\n\nx :: [! Int !]\nx =  [! 1, 2, 3 !]\n</code></pre> <p>Unboxed head strict lists are explicitly declared by placing a hash symbol (<code>#</code>) after the opening square bracket (<code>[ # ... ]</code>).</p> <pre><code>// Language: Clean\n\nx :: [ # Int ]\nx =  [ # 1, 2, 3 ]\n</code></pre> <p>Unboxed strict lists are explicitly declared by placing a hash symbol (<code>#</code>) and an exclamation mark (<code>!</code>) after the opening square bracket (<code>[ #! ... ]</code>).</p> <pre><code>// Language: Clean\n\nx :: [ #! Int ]\nx =  [ #! 1, 2, 3 ]\n</code></pre> <p>Overloaded lists are explicitly declared by placing a vertical (<code>|</code>) bar after the opening square bracket (<code>[ | ... ]</code>).</p> <pre><code>// Language: Clean\n\nx :: [ | Int ]\nx =  [ | 1, 2, 3 ]\n</code></pre> <p>%%</p>"},{"location":"predefined-data-types/PDT%20S%20List%20Type/#using-list-literal-as-pattern","title":"Using List Literal as Pattern","text":"<p>Example A:</p> <pre><code>// Language: Clean\n\nexampleA :: [ Int ] -&gt; Bool\nexampleA    [ x ]   =  True\nexampleA    _       =  False\n</code></pre> <p>The function <code>exampleA</code> returns <code>True</code> if it is called with a list of exactly one element.</p> <p>Example B:</p> <pre><code>// Language: Clean\n\nexampleB :: [ Int ]     -&gt; Bool\nexampleB    [ x, y, z ] =  True\nexampleB    _           =  False\n</code></pre> <p>The function <code>exampleB</code> returns <code>True</code> if it is called with a list of exactly three elements.</p> <p>There are many equivalent variants to the function <code>exampleB</code>.</p> <p>One variant is obtained by using colons instead of commas.</p> <pre><code>// Language: Clean\n\nexampleB :: [ Int ]            -&gt; Bool\nexampleB    [ x : y : z : [] ] =  True\nexampleB    _                  =  False\n</code></pre> <p>Another variant is obtained by using a combination of commas and colons.</p> <pre><code>// Language: Clean\n\nexampleB :: [ Int ]           -&gt; Bool\nexampleB    [ x , y : [ z ] ] =  True\nexampleB    _                 =  False\n</code></pre> <p>Example C:</p> <pre><code>// Language: Clean\n\nexampleC :: [ T ]      -&gt; Bool\nexampleC    [ x : ls ] =  True\nexampleC    _          =  False\n</code></pre> <p>The function <code>exampleC</code> returns true if it is called with a list of at least one element.</p> <p>Example D:</p> <pre><code>// Language: Clean\n\nexampleD :: [ Int ]          -&gt; Bool\nexampleD    [ x, y, z : ls ] =  True\nexampleD    _                =  False\n</code></pre> <p>The function <code>isLenGtThree</code> yields true if it is called with a list with at least three elements.</p> <p>Example E:</p> <pre><code>// Language: Clean\n\nexampleE :: [ Int ] -&gt; Bool\nexampleE    [ 1 ]   =  True\nexampleE    _       =  False\n</code></pre> <p>The function <code>isLenOne</code> yields true if it is called with a list of exactly one element. And that element must be one.</p> <p>Example F:</p> <pre><code>// Language: Clean\n\nexampleF :: [ Int ]     -&gt; Bool\nexampleF    [ 1, y, z ] =  True\nexampleF    _           =  False\n</code></pre> <p>The function <code>exampleF</code> returns true if it is called with a list of exactly three elements. The first element of the list must be 1.</p>"},{"location":"predefined-data-types/PDT%20S%20List%20Type/#labelling-list-pattern","title":"Labelling List Pattern","text":"<p>Lists are lazy by default, but other variants are: - head strict,  - spine strict,  - strict,  - head strict unboxed, and - strict unboxed. </p> <p>These variants are considered different type with unique time and space properties. Functions defined on one type of list cannot be applied to another.  However, overloaded functions can be introduced, which can be used on any type of list.</p> <p>%%</p>"},{"location":"predefined-data-types/PDT%20S%20Tuple%20Type/","title":"PDT S Tuple Type","text":""},{"location":"predefined-data-types/boolean-type/","title":"Boolean type","text":"<p>|</p>"},{"location":"predefined-data-types/boolean-type/#boolean-type","title":"Boolean type","text":"<p>For built-in functions and operations on Booleans, see stdbool.</p>"},{"location":"predefined-data-types/boolean-type/#type-annotation","title":"Type annotation","text":"<p>Booleans are annotated with <code>Bool</code>.</p> <pre><code>// CLEAN\n\nexpr :: Bool\nexpr =  1 == 1\n</code></pre>"},{"location":"predefined-data-types/boolean-type/#boolean-literals","title":"Boolean Literals","text":"<p>There are two Boolean literals.</p> <pre><code>// CLEAN\n\nboolT :: Bool\nboolT =  True\n\nboolF :: Bool\nboolF =  False\n</code></pre>"},{"location":"predefined-data-types/character-type/","title":"Character type","text":"<p>For built-In functions and operations on characters, see\u00a0stdchar.</p>"},{"location":"predefined-data-types/character-type/#type-annotation","title":"Type annotation","text":"<p>Characters are annotated with <code>Char</code>.</p> <pre><code>// Language: Clean\n\nexpr :: Char\nexpr =  'a'\n</code></pre>"},{"location":"predefined-data-types/character-type/#character-literals","title":"Character Literals","text":"<p>Character literals are created by enclosing a character within single quotation marks (<code>'...'</code>).</p> <pre><code>// Language: Clean\n\nx :: Char\nx =  '1'\nx =  'a'\nx =  'A'\nx =  '+'\n</code></pre> <p>%%</p>"},{"location":"predefined-data-types/character-type/#using-character-literal-as-pattern","title":"Using Character Literal as Pattern","text":""},{"location":"predefined-data-types/character-type/#example-a","title":"Example A","text":"<pre><code>// Language: Clean\n\nexampleA :: Char -&gt; Bool\nexampleA    'G'  =  True\nexampleA    _    =  False\n</code></pre> <p>Python equivalent:</p> <pre><code># Python\n\ndef exampleA(arg: str) -&gt; bool:\n    match arg:\n        case \"G\":\n            return True\n        case _:\n            return False\n</code></pre>"},{"location":"predefined-data-types/character-type/#example-b","title":"Example B","text":"<pre><code>// Language: Clean\n\nexampleB :: Char -&gt; Bool\nexampleB    'G'  =  True\nexampleB    'g'  =  True\nexampleB    _    =  False\n</code></pre> <p>Python equivalent:</p> <pre><code># Python\n\ndef exampleB(arg: str) -&gt; bool:\n    match arg:\n        case \"G\":\n            return True\n        case \"g\":\n            return True\n        case _:\n            return False\n</code></pre>"},{"location":"predefined-data-types/character-type/#example-c","title":"Example C","text":"<pre><code>// Language: Clean\n\nexampleC :: Char Char -&gt; Bool\nexampleC    'G'  'G'  =  True\nexampleC    _    _    =  False\n</code></pre> <p>Python equivalent:</p> <pre><code># Python\n\ndef exampleC(\n    argA: str, \n    argB: str\n) -&gt; bool:\n    match (argA, argB):\n        case (\"G\", \"G\"):\n            return True\n        case _:\n            return False\n</code></pre>"},{"location":"predefined-data-types/character-type/#example-d","title":"Example D","text":"<pre><code>// Language: Clean\n\nexampleD :: Char Char -&gt; Bool\nexampleD    'G'  'G'  =  True\nexampleD    'G'  'g'  =  True\nexampleD    'g'  'G'  =  True\nexampleD    'g'  'g'  =  True\nexampleD    _    _    =  False\n</code></pre> <p>Python equivalent:</p> <p><pre><code># Python\n\ndef exampleD(\n    argA: str, \n    argB: str\n) -&gt; bool:\n    match (argA, argB):\n        case (\"G\", \"G\"):\n            return True\n        case (\"G\", \"g\"):\n            return True\n        case (\"g\", \"G\"):\n            return True\n        case (\"g\", \"g\"):\n            return True\n        case _:\n            return False\n</code></pre> %%</p>"},{"location":"the-stdenv-module/","title":"The <code>StdEnv</code> module","text":"<ul> <li>StdArray</li> <li>StdBool</li> <li>StdChar</li> <li>StdCharList </li> <li>StdClass</li> <li>StdInt</li> <li>StdList </li> <li>StdMisc </li> <li>StdOrdList </li> <li>StdOverloaded </li> <li>StdReal</li> <li>StdString</li> <li>StdTuple </li> </ul>"},{"location":"the-stdenv-module/stdarray/","title":"StdArray","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module. It provides some basic functions which can be used to interact with arrays. When compared to other modules in the Standard Environment, this module is much smaller due to the implementations of arrays in CLEAN.</p> <p>Visit _SystemArray on Cloogle for source code of this module.</p> <p>A few functions were omitted due to their lack of documentation. Namely:</p> <ul> <li><code>createArray</code></li> <li><code>_createArray</code></li> <li><code>usize</code></li> <li><code>uselect</code></li> <li><code>replace</code></li> </ul>"},{"location":"the-stdenv-module/stdarray/#array-functions","title":"Array functions","text":""},{"location":"the-stdenv-module/stdarray/#select","title":"<code>select</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nselect :: {T} Int -&gt; T\nselect    Arr i   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the element at position <code>i</code> of the array. The index starts from zero.</p> <p>Results in a run-time error when over-indexing or under-indexing.</p> <pre><code>$ Run Time Error: index out of range\n</code></pre> <p>Note that CLEAN provides a syntax for array indexing.</p> <p>Usage</p> <pre><code>// CLEAN\n\nselect \"abcde\" 5     // Run-time error\nselect \"abcde\" 2     // 'c'\nselect \"abcde\" 0     // 'a'\nselect \"abcde\" (-1)  // Run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdarray/#size","title":"<code>size</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nsize :: {T} -&gt; Int\nsize    Arr =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the size of the array.</p> <p>Usage</p> <pre><code>// CLEAN\n\nsize \"abcde\"  // 5\nsize \"abcd\"   // 4\nsize \"abc\"    // 3\nsize \"ab\"     // 2\n</code></pre>"},{"location":"the-stdenv-module/stdarray/#update","title":"<code>update</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nupdate :: {T} Int T -&gt; {T}\nupdate    Arr i   e =&gt; ...\n</code></pre> <p>Behavior</p> <p>Updates the element at position <code>i</code> of the array with a new element <code>e</code>. The index starts from zero.</p> <p>Results in a run-time error when over-indexing or under-indexing.</p> <pre><code>$ Run Time Error: index out of range\n</code></pre> <p>Note that CLEAN provides a syntax for updating an element of an array at a specific index with a new element.</p> <p>Usage</p> <pre><code>// CLEAN\n\nupdate \"abcde\"   5  'X'  // Run-time error\nupdate \"abcde\"   2  'C'  // \"abCde\"\nupdate \"abcde\"   0  'A'  // \"Abcde\"\nupdate \"abcde\" (-1) 'X'  // Run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdbool/","title":"StdBool","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module. It provides definitions for logical operations.</p> <p>Although the size of the module is small compare to other primitive data types provided by CLEAN, this module is still quite important, on the account that it defines <code>logical equivalence</code>.</p> <p>That is correct, without this module, CLEAN has no idea how to perform one of the most fundamental operation is Boolean algebra.</p> <p>Visit StdBool on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdbool/#logical-operations","title":"Logical operations","text":"<p>Three logical operations are defined by this module.</p>"},{"location":"the-stdenv-module/stdbool/#logical-equivalence","title":"Logical equivalence","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(==) infix 4 :: Bool Bool -&gt; Bool\n(==)            a    b    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if both operands have the same logical value. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nTrue  == True   // True\nTrue  == False  // False\nFalse == True   // False\nFalse == False  // True\n</code></pre>"},{"location":"the-stdenv-module/stdbool/#logical-inclusive-disjunction","title":"Logical inclusive disjunction","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(||) infixr 2 :: Bool Bool -&gt; Bool\n(||)             a    b    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if at least one operand is true. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nTrue  || True   // True\nTrue  || False  // True\nFalse || True   // True\nFalse || False  // False\n</code></pre>"},{"location":"the-stdenv-module/stdbool/#logical-conjunction","title":"Logical conjunction","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&amp;&amp;) infixr 3 :: Bool Bool -&gt; Bool\n(&amp;&amp;)             a    b    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if both operands are true. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nTrue  &amp;&amp; True   // True\nTrue  &amp;&amp; False  // False\nFalse &amp;&amp; True   // False\nFalse &amp;&amp; False  // False\n</code></pre>"},{"location":"the-stdenv-module/stdbool/#logical-functions","title":"Logical functions","text":"<p>Technically speaking, <code>logical negation</code> is a unary operator, there is no such thing as a unary operator in CLEAN, as much as it pains me, I have decided to place it here.</p>"},{"location":"the-stdenv-module/stdbool/#logical-negation","title":"Logical negation","text":"<p>Signature</p> <pre><code>// CLEAN\n\nnot :: Bool -&gt; Bool\nnot    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Negates the logical value of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nnot True   // False\nnot False  // True\n</code></pre>"},{"location":"the-stdenv-module/stdbool/#conversions-from-boolean","title":"Conversions from Boolean","text":"<p>The function which is responsible for converting Boolean to other types is overloaded, which means the desired type must be unambiguous.</p> <p>Natively, Boolean may convert to string, but additional behavior may be added by creating new instances of <code>fromBool</code> class from the <code>StdOverloaded</code> module.</p>"},{"location":"the-stdenv-module/stdbool/#to-string","title":"To string","text":"<p>Signature</p> <pre><code>// CLEAN\n\nfromBool :: Bool -&gt; {#Char}\nfromBool    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the string representation of <code>a</code> which is either \"True\" or \"False\".</p> <p>Usage</p> <pre><code>// CLEAN\n\nexpr :: {#Char}\nexpr =  fromBool True   // \"True\"\nexpr =  fromBool False  // \"False\"\n</code></pre>"},{"location":"the-stdenv-module/stdchar/","title":"StdChar","text":"<p>This module can be imported directly or as a part of the <code>Standard Environment</code>. It defines many critical operations and functions on the character type.</p> <p>Visit StdChar on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdchar/#units","title":"Units","text":"<p>Neither of these unit characters are printable but they facilitate character addition and character subtraction.</p>"},{"location":"the-stdenv-module/stdchar/#zero-character","title":"Zero character","text":"<p>Implementation</p> <pre><code>// CLEAN\n\nzero ::  Char\nzero :== (toChar 0)\n</code></pre> <p>Definition</p> <p>Represents the character whose ASCII encoding is zero.</p>"},{"location":"the-stdenv-module/stdchar/#one-character","title":"One character","text":"<p>Implementation</p> <pre><code>// CLEAN\n\none ::  Char\none :== (toChar 1)\n</code></pre> <p>Definition</p> <p>Represents the character whose ASCII encoding is one.</p>"},{"location":"the-stdenv-module/stdchar/#character-arithmetic-operations","title":"Character arithmetic operations","text":"<p>The intuition is the same for both addition and subtract, difficult to formally define but much easier to informally explain.</p>"},{"location":"the-stdenv-module/stdchar/#addition","title":"Addition","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(+) infixl 6 :: Char Char -&gt; Char\n(+)             a    b    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns a character whose ASCII encoding is equal to the sum of ASCII encodings of <code>a</code> and <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n'1' + '1'  // 49 + 49 -&gt;  98 ('b')\n'A' + 'A'  // 65 + 65 -&gt; 130 ('\u00e9')\n'a' + 'a'  // 97 + 97 -&gt; 194 ('\u252c')\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#subtraction","title":"Subtraction","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(-) infixl 6 :: Char Char -&gt; Char\n(-)             a    b    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns a character whose ASCII encoding is equal to the difference of ASCII encodings of <code>a</code> and <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n'z' - '0'  // 122 - 48 -&gt; 74 ('J')\n'z' - '1'  // 122 - 49 -&gt; 73 ('I')\n'z' - '2'  //  97 + 50 -&gt; 72 ('H')\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#relational-operations","title":"Relational operations","text":"<p>Characters are compared based on their lexical order. Under the hood, CLEAN compares their ASCII encodings.</p>"},{"location":"the-stdenv-module/stdchar/#equal-to","title":"Equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(==) infix 4 :: Char Char -&gt; Bool\n(==)            a    b    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the ASCII encoding of <code>a</code> is equal to the ASCII encoding of <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n'1' == 'A'  // False\n'a' == '1'  // False\n'A' == 'a'  // False\n'1' == '1'  // True\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#not-equal-to","title":"Not equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;&gt;) infix 4 :: Char Char -&gt; Bool\n(&lt;&gt;)            a    b    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the ASCII encoding of <code>a</code> is not equal to the ASCII encoding of <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n'1' &lt;&gt; 'A'  // True\n'a' &lt;&gt; '1'  // True\n'A' &lt;&gt; 'a'  // True\n'1' &lt;&gt; '1'  // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#less-than","title":"Less than","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;) infix 4 :: Char Char -&gt; Bool\n(&lt;)            a    b    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the ASCII encoding of <code>a</code> is strictly less than the ASCII encoding of <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n'1' &lt; 'A'  // True\n'a' &lt; '1'  // False\n'A' &lt; 'a'  // True\n'1' &lt; '1'  // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#less-than-or-equal-to","title":"Less than or equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;=) infix 4 :: Char Char -&gt; Bool\n(&lt;=)            a    b    =&gt; ...\n</code></pre> <p>Behavior</p> <p>It returns true if the ASCII encoding of <code>a</code> is less than or equal to the ASCII encoding of <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n'1' &lt;= 'A'  // True\n'a' &lt;= '1'  // False\n'A' &lt;= 'a'  // True\n'1' &lt;= '1'  // True\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#greater-than","title":"Greater than","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&gt;) infix 4 :: Char Char -&gt; Bool\n(&gt;)            a    b    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the ASCII encoding of <code>a</code> is strictly greater than the ASCII encoding of <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n'1' &gt; 'A'  // False\n'a' &gt; '1'  // True\n'A' &gt; 'a'  // False\n'1' &gt; '1'  // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#greater-than-or-equal-to","title":"Greater than or equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&gt;=) infix 4 :: Char Char -&gt; Bool\n(&gt;=)            a    b    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the ASCII encoding of <code>a</code> is greater than or equal to the ASCII encoding of <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n'1' &gt;= 'A'  // False\n'a' &gt;= '1'  // True\n'A' &gt;= 'a'  // False\n'1' &gt;= '1'  // True\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#case-conversion-functions","title":"Case conversion functions","text":"<p>These two functions convert the case of a character they have been given.</p>"},{"location":"the-stdenv-module/stdchar/#toupper","title":"<code>toUpper</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\ntoUpper :: Char -&gt; Char\ntoUpper    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the upper case of <code>a</code>.</p> <p>If it is not possible to return an upper case of <code>a</code>, returns <code>a</code> as is.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntoUpper '1'  // '1'\ntoUpper 'a'  // 'A'\ntoUpper 'A'  // 'A'\ntoUpper '-'  // '-'\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#tolower","title":"<code>toLower</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\ntoLower :: Char -&gt; Char\ntoLower    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns lower case of <code>a</code>.</p> <p>If it is not possible to return a lower case of <code>a</code>, returns <code>a</code> as is.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntoLower '1'  // '1'\ntoLower 'a'  // 'a'\ntoLower 'A'  // 'a'\ntoLower '-'  // '-'\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#validator-functions","title":"Validator functions","text":"<p>I hope that the term validator function is not too absurd to anyone reading these notes, but I just could not find a better name.</p> <p>Note that these functions are closely related to the ASCII character encoding standard.</p>"},{"location":"the-stdenv-module/stdchar/#isupper","title":"<code>isUpper</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisUpper :: Char -&gt; Bool\nisUpper    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is an upper case character. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisUpper '1'  // False\nisUpper 'a'  // False\nisUpepr 'A'  // True\nisUpper '-'  // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#islower","title":"<code>isLower</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisLower :: Char -&gt; Bool\nisLower    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is a lower case character. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisLower '1'  // False\nisLower 'a'  // True\nisLower 'A'  // False\nisLower '-'  // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#isalphanum","title":"<code>isAlphanum</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisAlphanum :: Char -&gt; Bool\nisAlphanum    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is an alphanumeric character. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisAlphanum '1'  // True\nisAlphanum 'a'  // True\nisAlphanum 'A'  // True\nisAlphanum '-'  // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#isalpha","title":"<code>isAlpha</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisAlpha :: Char -&gt; Bool\nisAlpha    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is an alphabetic character. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisAlpha '1'  // False\nisAlpha 'a'  // True\nisAlpha 'A'  // True\nisAlpha '-'  // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#isdigit","title":"<code>isDigit</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisDigit :: Char -&gt; Bool\nisDigit    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is a decimal digit. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisDigit '1'  // True\nisDigit 'a'  // False\nisDigit 'A'  // False\nisDigit '-'  // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#isoctdigit","title":"<code>isOctDigit</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisOctDigit :: Char -&gt; Bool\nisOctDigit    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is an octal digit. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisOctDigit '1'  // True\nisOctDigit '8'  // False\nisOctDigit 'a'  // False\nisOctDigit 'A'  // False\nisOctDigit '-'  // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#ishexdigit","title":"<code>isHexDigit</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisHexDigit :: Char -&gt; Bool\nisHexDigit    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is a hexadecimal digit. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisHexDigit '1'  // True\nisHexDigit 'G'  // False\nisHexDigit 'a'  // True\nisHexDigit 'A'  // True\nisHexDigit '-'  // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#isascii","title":"<code>isAscii</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisAscii :: Char -&gt; Bool\nisAscii    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is a 7-bit ASCII character. Otherwise, returns false.</p> <p>The ASCII encoding of <code>a</code> has to be between 0 and 127 inclusive. See 7-bit ASCII characters for more information.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisAscii '1'  // True\nisAscii 'a'  // True\nisAscii 'A'  // True\nisAscii '-'  // True\nisAscii '\u00c7'  // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#iscontrol","title":"<code>isControl</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisControl :: Char -&gt; Bool\nisControl    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is an ASCII control character. Otherwise, returns false.</p> <p>See ASCII control characters for more information on ASCII control characters.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisControl '1'   // False\nisControl 'a'   // False\nisControl 'A'   // False\nisControl '-'   // False\nisControl '\\t'  // True\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#isprint","title":"<code>isPrint</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisControl :: Char -&gt; Bool\nisControl    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is an ASCII printable character. Otherwise, returns false.</p> <p>See ASCII printable character for more information on ASCII printable characters.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisPrint '1'  // True\nisPrint 'a'  // True\nisPrint 'A'  // True\nisPrint '-'  // True\nisPrint '\\t' // False\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#isspace","title":"<code>isSpace</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisSpace :: Char -&gt; Bool\nisSpace    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is a whitespace character. Otherwise, returns false.</p> <p>Whitespace characters include:</p> <ul> <li>space character</li> <li>horizontal tab <code>\\t</code></li> <li>form feed <code>\\f</code></li> <li>line feed <code>\\n</code></li> <li>carriage return <code>\\r</code></li> <li>vertical tab <code>\\v</code></li> </ul> <p>Usage</p> <pre><code>// CLEAN\n\nisSpace '1'   // False\nisSpace 'a'   // False\nisSpace 'A'   // False\nisSpace '-'   // False\nisSpace '\\t'  // True\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#conversions-to-character","title":"Conversions to character","text":"<p>Natively, only integers may be converted to character, but the programmer can define additional type conversions by creating new instances of <code>toChar</code> class from the <code>StdOverloaded</code> module.</p>"},{"location":"the-stdenv-module/stdchar/#from-integer","title":"From integer","text":"<p>Signature</p> <pre><code>// CLEAN\n\ntoChar :: Int -&gt; Char\ntoChar    a   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns a character whose ASCII encoding is <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntoChar 49  // '1'\ntoChar 65  // 'A'\ntoChar 97  // 'a'\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#conversions-from-character","title":"Conversions from character","text":"<p>The function responsible for converting character to other types is overloaded, which means it is a function with multiple signatures, so the desired type must be unambiguous.</p> <p>Natively, a character may convert to a string or an integer, but additional behavior may be added by creating new instances of <code>fromChar</code> class from the <code>StdOverloaded</code> module.</p> <p>Additionally, CLEAN provides an additional function for converting a character to an integer called <code>digitToInt</code>.</p>"},{"location":"the-stdenv-module/stdchar/#to-integer","title":"To integer","text":"<p>Signature</p> <pre><code>// CLEAN\n\nfromChar :: Char -&gt; Int\nfromChar    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the ASCII encoding of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nexpr :: Int\nexpr =  fromChar '1'  // 49\nexpr =  fromChar 'A'  // 65\nexpr =  fromChar 'a'  // 97\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#to-string","title":"To string","text":"<p>Signature</p> <pre><code>// CLEAN\n\nfromChar :: Char -&gt; {#Char}\nfromChar    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns a one-character string containing <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nexpr :: {#Char}\nexpr =  fromChar '1'  // \"1\"\nexpr =  fromChar 'A'  // \"A\"\nexpr =  fromChar 'a'  // \"a\"\n</code></pre>"},{"location":"the-stdenv-module/stdchar/#to-integer-with-offset","title":"To integer with offset","text":"<p>Signature</p> <pre><code>// CLEAN\n\ndigitToInt :: Char -&gt; Int\ndigitToInt    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the ASCII encoding of <code>a</code> offset by <code>-48</code>.</p> <p>The function itself is not too difficult to define, but the general use case lies in its convenience.</p> <p>Usage</p> <pre><code>// CLEAN\n\ndigitToInt '1'  // 49 - 48 -&gt;  1\ndigitToInt '2'  // 50 - 48 -&gt;  2\ndigitToInt '3'  // 51 - 48 -&gt;  3\ndigitToInt 'a'  // 97 - 48 -&gt;  49\ndigitToInt 'A'  // 65 - 48 -&gt;  17\ndigitToInt '-'  // 45 - 48 -&gt; -3\n</code></pre>"},{"location":"the-stdenv-module/stdcharlist/","title":"StdCharList","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module. If CLEAN ever has a proper IO and formatting functionalities, I think this module would be just that.</p> <p>Visit StdCharList on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdcharlist/#text-alignment-functions","title":"Text alignment functions","text":"<p>These functions pad the start and end of a character list until it has a specified length.</p>"},{"location":"the-stdenv-module/stdcharlist/#cjustify","title":"<code>cjustify</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\ncjustify :: Int     [Char] -&gt; [Char]\ncjustify    wLength cList  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Pads the start and end of character list <code>cList</code> with spaces until its width is equal to <code>wLength</code>.</p> <p>The padding at the end of the string is prioritized.</p> <p>This function does nothing if the length of the list is already equal to or greater than the desired length.</p> <p>Usage</p> <pre><code>// CLEAN\n\ncjustify 5 ['abc']  // [' ', 'a', 'b', 'c', ' ']\ncjustify 5 ['ab']   // [' ', 'a', 'b', ' ', ' ']\ncjustify 3 ['ab']   // ['a', 'b', ' ']\ncjustify 3 ['a']    // [' ', 'a', ' ']\ncjustify 1 ['ab']   // ['a', 'b']\n</code></pre>"},{"location":"the-stdenv-module/stdcharlist/#ljustify","title":"<code>ljustify</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nljustify :: Int     [Char] -&gt; [Char]\nljustify    wLength cList  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Pads the end of character list <code>cList</code> with spaces until its width is equal to <code>wLength</code>.</p> <p>This function does nothing if the length of the list is already equal to or greater than the desired length.</p> <p>Usage</p> <pre><code>// CLEAN\n\nljustify 5 ['abc']  // ['a', 'b', 'c', ' ', ' ']\nljustify 5 ['ab']   // ['a', 'b', ' ', ' ', ' ']\nljustify 3 ['ab']   // ['a', 'b', ' ']\nljustify 3 ['a']    // ['a', ' ', ' ']\nljustify 1 ['ab']   // ['a', 'b']\n</code></pre>"},{"location":"the-stdenv-module/stdcharlist/#rjustify","title":"<code>rjustify</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nrjustify :: Int     [Char] -&gt; [Char]\nrjustify    wLength cList  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Pads the start of character list <code>cList</code> with spaces until the width is equal to <code>wLength</code>.</p> <p>This function does nothing if the length of the list is already equal to or greater than the desired length.</p> <p>Usage</p> <pre><code>// CLEAN\n\nrjustify 5 ['abc']  // [' ', ' ', 'a', 'b', 'c']\nrjustify 5 ['ab']   // [' ', ' ', 'a', 'b']\nrjustify 3 ['ab']   // [' ', 'a', 'b']\nrjustify 3 ['a']    // [' ', ' ', 'a']\nrjustify 1 ['ab']   // ['a', 'b']\n</code></pre>"},{"location":"the-stdenv-module/stdcharlist/#line-manipulation-functions","title":"Line manipulation functions","text":"<p>These functions transform and interact with the newline characters in a character list by either removing or adding them.</p>"},{"location":"the-stdenv-module/stdcharlist/#flatlines","title":"<code>flatlines</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nflatlines :: [[Char]] -&gt; [Char]\nflatlines    cMat     =&gt; ...\n</code></pre> <p>Behavior</p> <p>Flattens two-dimensional character list <code>cMat</code> and join them with newline characters.</p> <p>Usage</p> <pre><code>// CLEAN\n\nflatlines [['a'], ['b']]  // ['a', '\\n', 'b', '\\n']\nflatlines [['a']]         // ['a', '\\n']\nflatlines []              // []\n</code></pre>"},{"location":"the-stdenv-module/stdcharlist/#mklines","title":"<code>mklines</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nmklines :: [Char] -&gt; [[Char]]\nmklines    cList  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Splits a character list <code>cList</code> at newline characters and transform it into two-dimensional character list. The newline characters are removed from the result.</p> <p>Usage</p> <pre><code>// CLEAN\n\nmklines ['a', '\\n', 'b', '\\n']  // [['a'], ['b']]\nmklines ['a', '\\n']             // [['a']]\nmklines []                      // []\n</code></pre>"},{"location":"the-stdenv-module/stdclass/","title":"StdClass","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module.</p> <p>The distinction between this module and the <code>StdOverloaded</code> module is that this module builds on top of the <code>StdOverloaded</code> module.</p> <p>Visit StdClass on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdclass/#arithmetic-classes","title":"Arithmetic classes","text":""},{"location":"the-stdenv-module/stdclass/#plusmin","title":"<code>PlusMin</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass PlusMin T | (+ T) &amp; (- T) &amp; (zero T)\n</code></pre> <p>This class does not define additional operators or functions on the type <code>T</code>, so it serves the purpose of a shorthand to the three classes.</p> <p>Instead of writing all three classes, you can simply use this class instead, given that the type that you are working with is an instance of the classes mentioned.</p>"},{"location":"the-stdenv-module/stdclass/#multdiv","title":"<code>MultDiv</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass MultDiv T | (* T) &amp; (/ T) &amp; (one T)\n</code></pre> <p>This class does not define additional operators or functions on the type <code>T</code>, so it serves the purpose of a shorthand to the three classes.</p> <p>Instead of writing all three classes, you can simply use this class instead, given that the type that you are working with is an instance of the classes mentioned.</p>"},{"location":"the-stdenv-module/stdclass/#arith","title":"<code>Arith</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass Arith T | (PlusMin T) &amp; (MultDiv T) &amp; (abs T) &amp; (sign T) &amp; (~ T)\n</code></pre> <p>This class does not define additional operators or functions on the type <code>T</code>, so it serves the purpose of a shorthand to the classes mentioned.</p> <p>Instead of writing all classes, you can simply use this class instead, given that the type that you are working with is an instance of the classes mentioned.</p>"},{"location":"the-stdenv-module/stdclass/#incdec","title":"<code>IncDec</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass IncDec T | (+ T) &amp; (- T) &amp; (one T) &amp; (zero T)\nwhere\n    inc :: T -&gt; T | (+ T) &amp; (one T)\n    inc    x =&gt; ...\n    dec :: T -&gt; T | (- T) &amp; (one T)\n    inc    x =&gt; ...\n</code></pre> <p>This class defines two additional functions on the type <code>T</code>.</p> <p>The behavior of both functions are determined by the definition of the <code>addition</code>, <code>subtraction</code>. and <code>one</code> unit.</p> <p>Under the hood, the function <code>inc</code> performs <code>addition</code> operation using the argument <code>x</code> and <code>one</code> as operands. Similarly, the function <code>dec</code> performs <code>subtraction</code> operation using the argument <code>x</code> and <code>one</code> as operands.</p>"},{"location":"the-stdenv-module/stdclass/#enum","title":"<code>Enum</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass Enum T | (&lt; T) &amp; (IncDec T)\n</code></pre> <p>This class does not define additional operators or functions on the type <code>T</code>, however, dot-dot syntax requires this class to operate.</p>"},{"location":"the-stdenv-module/stdclass/#relational-classes","title":"Relational classes","text":""},{"location":"the-stdenv-module/stdclass/#eq","title":"<code>Eq</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass Eq T | (== T)\nwhere\n    (&lt;&gt;) infixl 4 :: T T -&gt; Bool\n    (&lt;&gt;)          :: x y =&gt; ...\n</code></pre> <p>This class defines the <code>not equal</code> operation for the type <code>T</code> if it is an instance of the <code>Equalilty</code> class.</p> <p>Under the hood, the function performs equality operation using <code>x</code> and <code>y</code> as operands and returns the negated logical value.</p>"},{"location":"the-stdenv-module/stdclass/#ord","title":"<code>Ord</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass Ord T | (&lt; T)\nwhere\n    (&gt;)  infixl 4 :: T T  -&gt; Bool\n    (&gt;)           :: x y  =&gt; ...\n\n    (&lt;=) infixl 4 :: T T -&gt; Bool\n    (&lt;=)          :: x y =&gt; ...\n\n    (&gt;=) infixl 4 :: T T -&gt; Bool\n    (&gt;=)          :: x y =&gt; ...\n\n    min :: T T -&gt; T\n    min :: x y =&gt; ...\n\n    max :: T T -&gt; T\n    max :: x y =&gt; ...\n</code></pre> <p>Definition</p> <p>Defines the rest of the relational operations, as well as, the <code>min</code>, and <code>max</code> functions for the type <code>T</code> if it is an instance of the <code>Less than</code> class.</p> <p>The operators and functions are defined in terms of <code>Less than</code> function and <code>not</code> function (unary operator).</p>"},{"location":"the-stdenv-module/stdint/","title":"StdInt","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module. It provides definition for many critical operations and functions on integers.</p> <p>Visit StdInt on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdint/#units","title":"Units","text":"<p>The integer units follow their definitions in mathematics.</p>"},{"location":"the-stdenv-module/stdint/#zero","title":"Zero","text":"<p>Implementation</p> <pre><code>// CLEAN\n\nzero ::  Int\nzero :== 0\n</code></pre> <p>Definition</p> <p>Represents the additive identity of integers.</p>"},{"location":"the-stdenv-module/stdint/#one","title":"One","text":"<p>Implementation</p> <pre><code>// CLEAN\n\none ::  Int\none :== 1\n</code></pre> <p>Definition</p> <p>Represents the multiplicative identity of integers.</p>"},{"location":"the-stdenv-module/stdint/#math-operations","title":"Math operations","text":"<p>The definition and behavior of these operators follow their mathematic counterpart. It is worth noting that, natively, these operations only work with integer operands, but the programmer can define additional behaviors and functionalities.</p>"},{"location":"the-stdenv-module/stdint/#addition","title":"Addition","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(+) infixl 6 :: Int Int -&gt; Int\n(+)             a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Adds <code>a</code> and <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  1  +   1   //  2\n  1  + (-1)  //  0\n(-1) +   1   //  0\n(-1) + (-1)  // -2\n</code></pre>"},{"location":"the-stdenv-module/stdint/#subtraction","title":"Subtraction","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(-) infixl 6 :: Int Int -&gt; Int\n(-)             a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Subtracts <code>b</code> from <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  1  -   1  //  0\n  1  - (-1) //  2\n(-1) -   1  // -2\n(-1) - (-1) //  0\n</code></pre>"},{"location":"the-stdenv-module/stdint/#multiplication","title":"Multiplication","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(*) infixl 7 :: Int Int -&gt; Int\n(*)             a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Multiplies <code>a</code> and <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  1  *   1  //  1\n  1  * (-1) // -1\n(-1) *   1  // -1\n(-1) * (-1) //  1\n</code></pre>"},{"location":"the-stdenv-module/stdint/#floor-division","title":"Floor Division","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(/) infixl 7 :: Int Int -&gt; Int\n(/)             a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Divides <code>a</code> by <code>b</code> rounds the result down to the nearest integer..</p> <p>Results in a silent run-time crash if <code>b</code> is zero.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  1  /   1   //  1\n  1  / (-1)  // -1\n(-1) /   1   // -1\n(-1) / (-1)  //  1\n  7  /   0   //  silently crashes\n</code></pre>"},{"location":"the-stdenv-module/stdint/#reminder-division","title":"Reminder Division","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(rem) infix 7 :: Int Int -&gt; Int\n(rem)            a   b   =&gt; ...\n</code></pre> <p>and</p> <pre><code>// CLEAN\n\n(mod) infix 7 :: Int Int -&gt; Int\n(mod)            a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the reminder after dividing <code>a</code> by <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  3  mod (-2)  //  1\n(-3) mod (-2)  // -1\n(-3) mod   2   // -1\n  3  mod   2   //  1\n</code></pre>"},{"location":"the-stdenv-module/stdint/#exponentiation","title":"Exponentiation","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(^) infixr 8 :: Int Int -&gt; Int\n(^)             a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Raises <code>a</code> to the power of <code>b</code>.</p> <p>Results in a run-time error if <code>b</code> is negative.</p> <pre><code>$ ^ (Int) called with negative power argument\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\n  1  ^   1   //  1\n  1  ^ (-1)  //  Run-time error\n(-1) ^   1   // -1\n(-1) ^ (-1)  //  Run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdint/#math-functions","title":"Math functions","text":"<p>Some of these \"functions\" are unary operators, but there is no such thing as a unary operator in CLEAN, so to keep things tidy, I have decided to place them here.</p>"},{"location":"the-stdenv-module/stdint/#negation","title":"Negation","text":"<p>Signature</p> <pre><code>// CLEAN\n\n~ :: Int -&gt; Int\n~    a   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Inverts the sign <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n~  0   //  0\n~  1   // -1\n~(-1)  //  1\n</code></pre>"},{"location":"the-stdenv-module/stdint/#sign","title":"<code>sign</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nsign :: Int -&gt; Int\nsign    a   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the sign of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nsign   1   //  1\nsign   0   //  0\nsign (-1)  // -1\n</code></pre>"},{"location":"the-stdenv-module/stdint/#abs","title":"<code>abs</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nabs :: Int -&gt; Int\nabs    a   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the absolute value of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nabs   1   // 1\nabs   0   // 0\nabs (-1)  // 1\n</code></pre>"},{"location":"the-stdenv-module/stdint/#gcd","title":"<code>gcd</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\ngcd :: Int Int -&gt; Int\ngcd    a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the greatest common divisor of <code>a</code> and <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\ngcd   3    2   // 1\ngcd (-3)   2   // 1\ngcd   3  (-2)  // 1\ngcd (-3) (-2)  // 1\n</code></pre>"},{"location":"the-stdenv-module/stdint/#lcm","title":"<code>lcm</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nlcm :: Int Int -&gt; Int\nlcm    a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the least common multiple of <code>a</code> and <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nlcm   3    2   // 6\nlcm (-3)   2   // 6\nlcm   3  (-2)  // 6\nlcm (-3) (-2)  // 6\n</code></pre>"},{"location":"the-stdenv-module/stdint/#relational-operations","title":"Relational operations","text":"<p>These relations behave in the exact same way as their math counterpart.</p>"},{"location":"the-stdenv-module/stdint/#equal-to","title":"Equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(==) infix 4 :: Int Int -&gt; Bool\n(==)            a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is equal to <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5  ==   2   // False\n(-5) ==   2   // False\n  5  == (-2)  // False\n(-5) == (-2)  // False\n(-2) == (-2)  // True\n</code></pre>"},{"location":"the-stdenv-module/stdint/#not-equal-to","title":"Not equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;&gt;) infix 4 :: Int Int -&gt; Bool\n(&lt;&gt;)            a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is not equal to <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5  &lt;&gt;   2   // True\n(-5) &lt;&gt;   2   // True\n  5  &lt;&gt; (-2)  // True\n(-5) &lt;&gt; (-2)  // True\n(-2) &lt;&gt; (-2)  // False\n</code></pre>"},{"location":"the-stdenv-module/stdint/#less-than","title":"Less Than","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;) infix 4 :: Int Int -&gt; Bool\n(&lt;)            a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is strictly less than <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5  &lt;   2   // False\n(-5) &lt;   2   // True\n  5  &lt; (-2)  // False\n(-5) &lt; (-2)  // True\n(-2) &lt; (-2)  // False\n</code></pre>"},{"location":"the-stdenv-module/stdint/#less-than-or-equal-to","title":"Less than or equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;=) infix 4 :: Int Int -&gt; Bool\n(&lt;=)            a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is less than or equal to <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5  &lt;=   2   // False\n(-5) &lt;=   2   // True\n  5  &lt;= (-2)  // False\n(-5) &lt;= (-2)  // True\n(-2) &lt;= (-2)  // True\n</code></pre>"},{"location":"the-stdenv-module/stdint/#greater-than","title":"Greater than","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&gt;) infix 4 :: Int Int -&gt; Bool\n(&gt;)            a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is strictly greater than <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5  &gt;   2   // True\n(-5) &gt;   2   // False\n  5  &gt; (-2)  // True\n(-5) &gt; (-2)  // False\n(-2) &gt; (-2)  // False\n</code></pre>"},{"location":"the-stdenv-module/stdint/#greater-than-or-equal-to","title":"Greater than or equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&gt;=) infix 4 :: Int Int -&gt; Bool\n(&gt;=)            a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is greater than or equal to <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5  &gt;=   2   // True\n(-5) &gt;=   2   // False\n  5  &gt;= (-2)  // True\n(-5) &gt;= (-2)  // False\n(-2) &gt;= (-2)  // True\n</code></pre>"},{"location":"the-stdenv-module/stdint/#bitwise-operations","title":"Bitwise operations","text":"<p>These operators and functions provide a method to interact with the bits of integers.</p> <p>A quick web search should provide more details about the formal definition of each bitwise operator.</p>"},{"location":"the-stdenv-module/stdint/#bitwise-and","title":"Bitwise and","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(bitand) infixl 6 :: Int Int -&gt; Int\n(bitand)             a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns bitwise AND of <code>a</code> and <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5  bitand   2   //  0\n(-5) bitand   2   //  2\n  5  bitand (-2)  //  4\n(-5) bitand (-2)  // -6\n</code></pre>"},{"location":"the-stdenv-module/stdint/#bitwise-or","title":"Bitwise or","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(bitor) infixl 6 :: Int Int -&gt; Int\n(bitor)             a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns bitwise OR of <code>a</code> and <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5  bitor   2   //  7\n(-5) bitor   2   // -5\n  5  bitor (-2)  // -1\n(-5) bitor (-2)  // -1\n</code></pre>"},{"location":"the-stdenv-module/stdint/#bitwise-exclusive-or","title":"Bitwise exclusive or","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(bitxor) infixl 6 :: Int Int -&gt; Int\n(bitxor)             a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns bitwise XOR of <code>a</code> and <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5  bitxor   2   //  7\n(-5) bitxor   2   // -7\n  5  bitxor (-2)  // -5\n(-5) bitxor (-2)  //  5\n</code></pre>"},{"location":"the-stdenv-module/stdint/#bitwise-left-shift","title":"Bitwise left shift","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;&lt;) infix 7 :: Int Int -&gt; Int\n(&lt;&lt;)            a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Shifts <code>a</code> to the left by <code>b</code> bits.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5  &lt;&lt;   2   //  20\n(-5) &lt;&lt;   2   // -20\n  5  &lt;&lt; (-2)  //  4611686018427387904\n(-5) &lt;&lt; (-2)  // -4611686018427387904\n</code></pre>"},{"location":"the-stdenv-module/stdint/#bitwise-right-shift","title":"Bitwise right shift","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&gt;&gt;) infix 7 :: Int Int -&gt; Int\n(&gt;&gt;)            a   b   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Shifts <code>a</code> to the right by <code>b</code> bits.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5  &gt;&gt;   2   //  1\n(-5) &gt;&gt;   2   // -2\n  5  &gt;&gt; (-2)  //  0\n(-5) &gt;&gt; (-2)  // -1\n</code></pre>"},{"location":"the-stdenv-module/stdint/#bitwise-functions","title":"Bitwise functions","text":"<p>There is only one function which classifies under this section, its behavior is not well-documented.</p>"},{"location":"the-stdenv-module/stdint/#bitnot","title":"<code>bitnot</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nbitnot :: Int -&gt; Int\nbitnot    a   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns bitwise one-complement of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nbitnot (-5)  //  -4\nbitnot (-2)  //   1\nbitnot   2   //  -3\nbitnot   5   //  -6\n</code></pre>"},{"location":"the-stdenv-module/stdint/#validator-functions","title":"Validator functions","text":"<p>These function takes an integer as an argument and check whether it has a certain property or not.</p>"},{"location":"the-stdenv-module/stdint/#iseven","title":"<code>isEven</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisEven :: Int -&gt; Bool\nisEven    a   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is an even integer. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisEven  2  // False\nisEven  1  // True\nisEven  0  // True\nisEven -1  // True\nisEven -2  // False\n</code></pre>"},{"location":"the-stdenv-module/stdint/#isodd","title":"<code>isOdd</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisOdd :: Int -&gt; Bool\nisOdd    a   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is an odd integer. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisOdd  2  // True\nisOdd  1  // False\nisOdd  0  // False\nisOdd -1  // False\nisOdd -2  // True\n</code></pre>"},{"location":"the-stdenv-module/stdint/#conversions-to-integer","title":"Conversions to integer","text":"<p>Natively, three types can convert to integer, namely, real numbers, characters, and strings.</p>"},{"location":"the-stdenv-module/stdint/#from-real-number","title":"From real number","text":"<p>Signature</p> <pre><code>// CLEAN\n\ntoInt :: Real -&gt; Int\ntoInt    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Rounds <code>a</code> up or down to its nearest integer.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntoInt   1.5   //  2\ntoInt   1.4   //  1\ntoInt   0.0   //  0\ntoInt (-1.4)  // -1\ntoInt (-1.5)  // -2\n</code></pre>"},{"location":"the-stdenv-module/stdint/#from-character","title":"From character","text":"<p>Signature</p> <pre><code>// CLEAN\n\ntoInt :: Char -&gt; Int\ntoInt    a    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the ASCII encoding of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntoInt '1'  //  49\ntoInt '9'  //  59\ntoInt 'A'  //  65\ntoInt 'Z'  //  90\ntoInt 'a'  //  97\ntoInt 'z'  // 122\n</code></pre>"},{"location":"the-stdenv-module/stdint/#from-string","title":"From string","text":"<p>Signature</p> <pre><code>// CLEAN\n\ntoInt :: {#Char} -&gt; Int\ntoInt    a       =&gt; ...\n</code></pre> <p>Behavior</p> <p>Parses <code>a</code> as an integer. Returns zero if when the parsing is unsuccessful.</p> <p>The string should only contain decimal digits and the minus sign. The parsing step will be unsuccessful if it contains any other character.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntoInt \"1.0\"   //  0\ntoInt \"1\"     //  1\ntoInt \"0\"     //  0\ntoInt \"-1\"    // -1\ntoInt \"-1.0\"  //  0\n</code></pre>"},{"location":"the-stdenv-module/stdint/#conversions-from-integer","title":"Conversions from integer","text":"<p>The function responsible for type conversion is overloaded, it has the same parameter but different return type, so to use it, the desired type must be unambiguous.</p>"},{"location":"the-stdenv-module/stdint/#to-real-number","title":"To real number","text":"<p>Signature</p> <pre><code>// CLEAN\n\nfromInt :: Int -&gt; Real\nfromInt    a   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Sets the decimal places of <code>a</code> to zeroes.</p> <p>Usage</p> <pre><code>// CLEAN\n\nexpr :: Real\nexpr =  fromInt  1   //  1.0\nexpr =  fromInt  19  // 19.0\nexpr =  fromInt  0   //  0.0\n</code></pre>"},{"location":"the-stdenv-module/stdint/#to-character","title":"To character","text":"<p>Signature</p> <pre><code>// CLEAN\n\nfromInt :: Int -&gt; Char\nfromInt    a   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the character whose ASCII encoding is <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nexpr :: Char\nexpr =  fromInt 49   // '1'\nexpr =  fromInt 59   // '9'\nexpr =  fromInt 65   // 'A'\nexpr =  fromInt 90   // 'Z'\nexpr =  fromInt 97   // 'a'\nexpr =  fromInt 122  // 'z'\n</code></pre>"},{"location":"the-stdenv-module/stdint/#to-string","title":"To string","text":"<p>Signature</p> <pre><code>// CLEAN\n\nfromInt :: Int -&gt; {#Char}\nfromInt    a   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the string representation of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nexpr :: {#Char}\nexpr =  fromInt 1   // \"1\"\nexpr =  fromInt 19  // \"19\"\nexpr =  fromInt 0   // \"0\"\n</code></pre>"},{"location":"the-stdenv-module/stdlist/","title":"StdList","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module. It provides definitions for operators and functions critical for interaction of lists.</p> <p>Visit StdList on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdlist/#basic-operations","title":"Basic operations","text":"<p>These operators provide ways to manipulate lists. Some of these operators have great importance since they are the only way of interacting with lists.</p>"},{"location":"the-stdenv-module/stdlist/#concatenation","title":"Concatenation","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(++) infixr 5 :: [T] [T] -&gt; [T]\n(++)             lsA lsB =&gt; ...\n</code></pre> <p>Behavior</p> <p>Concatenates the list <code>lsB</code> to the end of list <code>lsA</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n[1, 2, 3] ++ [4, 5]  // [1, 2, 3, 4, 5]\n[1, 2, 3] ++ [4]     // [1, 2, 3, 4]\n[1, 2, 3] ++ []      // [1, 2, 3]\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#indexing","title":"Indexing","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(!!) infixl 9 :: [T] Int -&gt; T\n(!!)             ls  idx =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the element at position <code>idx</code> of the list <code>ls</code>. CLEAN starts counting index from zero.</p> <p>Results in a run-time error when over-indexing or under-indexing.</p> <pre><code>$ Subscript error in !!,index too large\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\n[1, 2, 3] !!   5   // Run-time error\n[1, 2, 3] !!   2   // 3\n[1, 2, 3] !!   0   // 1\n[1, 2, 3] !! (-1)  // Run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#slicing","title":"Slicing","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(%) infixl 9 :: [T] (Int, Int) -&gt; [T]\n(%)             ls  (l, r)     =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns elements inclusively between position <code>l</code> and position <code>r</code> of the list  <code>A</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n[1, 2, 3] % (  2,  4)  // [3]\n[1, 2, 3] % (  0,  2)  // [1, 2, 3]\n[1, 2, 3] % ((-1), 0)  // [1, 2]\n[1, 2, 3] % ((-2), 5)  // [1, 2, 3]\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#relational-operations","title":"Relational operations","text":"<p>CLEAN performs pairwise to compare two lists, so by extension, two lists are only comparable if they contain the same element type.</p> <p>Additionally, if the relational operation is not defined on the element type, it is not meaningful to compare two lists containing such type.</p> <p>I suggest that if the behavior is unclear, check the usage example. I try to include a comprehensive use case for each operators.</p>"},{"location":"the-stdenv-module/stdlist/#equal-to","title":"Equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(==) infix 4 :: [T] [T] -&gt; Bool | == T\n(==)            lsA lsB =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Equality</code> class from the <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Returns true if the list <code>lsA</code> and the list <code>lsB</code> are pairwise equal. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n[]     == []      // True\n[1, 2] == [1, 2]  // True\n[1, 2] == [1]     // False\n[1]    == [1, 2]  // False\n[1, 2] == [1, 3]  // False\n[1, 3] == [1, 2]  // False\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#not-equal-to","title":"Not equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;&gt;) infix 4 :: [T] [T] -&gt; Bool | == T\n(&lt;&gt;)            A   B   =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Equality</code> class from the <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Returns true if list <code>A</code> and list <code>B</code> are not pairwise equal. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n[]     &lt;&gt; []      // False\n[1, 2] &lt;&gt; [1, 2]  // False\n[1, 2] &lt;&gt; [1]     // True\n[1]    &lt;&gt; [1, 2]  // True\n[1, 2] &lt;&gt; [1, 3]  // True\n[1, 3] &lt;&gt; [1, 2]  // True\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#less-than","title":"Less than","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;) infix 4 :: [T] [T] -&gt; Bool | Ord T\n(&lt;)            lsA lsB =&gt; ...\n</code></pre> <p>The type <code>T</code> must be and instance of the <code>Ord</code> class from the <code>StdClass</code> module.</p> <p>Behavior</p> <p>Returns true if list <code>lsA</code> and list <code>lsB</code> are pairwise less than. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n[]     &lt; []      // False\n[1, 2] &lt; [1, 2]  // False\n[1, 2] &lt; [1]     // False\n[1]    &lt; [1, 2]  // True\n[1, 2] &lt; [1, 3]  // True\n[1, 3] &lt; [1, 2]  // False\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#less-than-or-equal-to","title":"Less than or equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;=) infix 4 :: [T] [T] -&gt; Bool | Ord T\n(&lt;=)            lsA lsB =&gt; ...\n</code></pre> <p>The type <code>T</code> must be and instance of the <code>Ord</code> class from the <code>StdClass</code> module.</p> <p>Behavior</p> <p>Returns true if list <code>lsA</code> and list <code>lsB</code> are pairwise less than or equal. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n[]     &lt;= []     // True\n[1, 2] &lt;= [1, 2] // True\n[1, 2] &lt;= [1]    // False\n[1]    &lt;= [1, 2] // True\n[1, 2] &lt;= [1, 3] // True\n[1, 3] &lt;= [1, 2] // False\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#greater-than","title":"Greater than","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;=) infix 4 :: [T] [T] -&gt; Bool | Ord T\n(&lt;=)            lsA lsB =&gt; ...\n</code></pre> <p>The type <code>T</code> must be and instance of the <code>Ord</code> class from the <code>StdClass</code> module.</p> <p>Behavior</p> <p>Returns true if list <code>lsA</code> and list <code>lsB</code> are pairwise greater than. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n[]     &gt; []      // False\n[1, 2] &gt; [1, 2]  // False\n[1, 2] &gt; [1]     // True\n[1]    &gt; [1, 2]  // False\n[1, 2] &gt; [1, 3]  // False\n[1, 3] &gt; [1, 2]  // True\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#greater-than-or-equal-to","title":"Greater than or equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&gt;=) infix 4 :: [T] [T] -&gt; Bool | Ord T\n(&gt;=)            lsA lsB =&gt; ...\n</code></pre> <p>The type <code>T</code> must be and instance of the <code>Ord</code> class from the <code>StdClass</code> module.</p> <p>Behavior</p> <p>Returns true if list <code>lsA</code> and list <code>lsB</code> are pairwise greater than or equal. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n[]     &gt;= []      // True\n[1, 2] &gt;= [1, 2]  // True\n[1, 2] &gt;= [1]     // True\n[1]    &gt;= [1, 2]  // False\n[1, 2] &gt;= [1, 3]  // False\n[1, 3] &gt;= [1, 2]  // True\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#basic-functions","title":"Basic functions","text":"<p>These functions provide methods to interacting with lists. Unlike some operations, the behaviors of these functions can be achieved using regular CLEAN syntax, but they are provided mostly for convenience purposes.</p>"},{"location":"the-stdenv-module/stdlist/#length","title":"<code>length</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nlength :: [T] -&gt; Int\nlength    ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the number of elements in the list.</p> <p>Usage</p> <pre><code>// CLEAN\n\nlength [1, 2, 3]  // 3\nlength [1, 2]     // 2\nlength [1]        // 1\nlength []         // 0\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#flatten","title":"<code>flatten</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nflatten :: [[T]] -&gt; [T]\nflatten    mat   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Transforms a two-dimensional list into a one-dimensional list.</p> <p>Usage</p> <pre><code>// CLEAN\n\nflatten [[1], [2], [3]]  // [1, 2, 3]\nflatten [[1], [2, 3]]    // [1, 2, 3]\nflatten [[1, 2, 3]]      // [1, 2, 3]\nflatten []               // []\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#hd","title":"<code>hd</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nhd :: [T] -&gt; T\nhd    ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the first element of the list.</p> <p>Results in a run-time error if the given list is empty.</p> <pre><code>$ hd of []\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\nhd [1, 2, 3]  // 1\nhd [1, 2]     // 1\nhd [1]        // 1\nhd []         // run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#tl","title":"<code>tl</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\ntl :: [T] -&gt; [T]\ntl    ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the list with the first element excluded.</p> <p>Results in a run-time error if the list is empty.</p> <pre><code>$ tl of []\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\ntl [1, 2, 3]  // [2, 3]\ntl [1, 2]     // [2]\ntl [1]        // []\ntl []         // run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#last","title":"<code>last</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nlast :: [T] -&gt; T\nlast    ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the last element of the list.</p> <p>Results in a run-time error if the given list is empty.</p> <pre><code>$ last of []\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\nlast [1, 2, 3]  // 3\nlast [1, 2]     // 2\nlast [1]        // 1\nlast []         // run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#init","title":"<code>init</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\ninit :: [T] -&gt; [T]\ninit    ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the list with the last element excluded.</p> <p>Results in a run-time error if the given list is empty.</p> <pre><code>$ init of []\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\ninit [1, 2, 3]  // [1, 2]\ninit [1, 2]     // [1]\ninit [1]        // []\ninit []         // NOT OK\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#take","title":"<code>take</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\ntake :: Int [T] -&gt; [T]\ntake    cnt ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the first <code>cnt</code> elements of of the list.</p> <p>If <code>cnt</code> is greater than or equal to the length of the list, returns the entire list.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntake 2 [1, 2, 3]  // [1, 2]\ntake 1 [1, 2]     // [1]\ntake 0 [1]        // []\ntake 0 []         // []\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#drop","title":"<code>drop</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\ndrop :: Int [T] -&gt; [T]\ndrop    cnt ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the list with the first <code>cnt</code> elements excluded.</p> <p>If <code>cnt</code> is greater than or equal to the length of the list, returns an empty list.</p> <p>Usage</p> <pre><code>// CLEAN\n\ndrop 2 [1, 2, 3]  // [3]\ndrop 1 [1, 2]     // [2]\ndrop 1 [1]        // []\ndrop 0 []         // []\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#reverse","title":"<code>reverse</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nreverse :: [T] -&gt; [T]\nreverse    ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns the list in reversed order.</p> <p>Usage</p> <pre><code>// CLEAN\n\nreverse [1, 2, 3]  // [3, 2, 1]\nreverse [1, 2]     // [2, 1]\nreverse [1]        // [1]\nreverse []         // []\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#insertat","title":"<code>insertAt</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\ninsertAt :: Int T [T] -&gt; [T]\ninsertAt    idx e ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Inserts an element <code>e</code> into the position <code>idx</code> of the list. The previous element at the position <code>idx</code> is moved to the right if there is such an element.</p> <p>The position starts from zero.</p> <p>Usage</p> <pre><code>// CLEAN\n\ninsertAt   2  9 [1, 2]  // [1, 2, 9]\ninsertAt   1  9 [1, 2]  // [1, 9, 2]\ninsertAt   0  9 [1, 2]  // [9, 1, 2]\ninsertAt (-1) 9 [1, 2]  // [1, 2, 9]\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#removeat","title":"<code>removeAt</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nremoveAt :: Int [T] -&gt; [T]\nremoveAt    idx ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Removes the element at position <code>idx</code> from the list. The position starts from zero.</p> <p>Usage</p> <pre><code>// CLEAN\n\nremoveAt   2  [1, 2]  // [1, 2]\nremoveAt   1  [1, 2]  // [1]\nremoveAt   0  [1, 2]  // [2]\nremoveAt (-1) [1, 2]  // [1,2]\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#updateat","title":"<code>updateAt</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nupdateAt :: Int T [T] -&gt; [T]\nupdateAt    idx e ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Overrides the element at position <code>idx</code> with a new element <code>e</code>.</p> <p>If the <code>idx</code> is not a valid index of the list, does nothing.</p> <p>Usage</p> <pre><code>// CLEAN\n\nupdateAt   2  9 [1, 2]  // [1, 2]\nupdateAt   1  9 [1, 2]  // [1, 9]\nupdateAt   0  9 [1, 2]  // [9, 2]\nupdateAt (-1) 9 [1, 2]  // [1, 2]\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#splitat","title":"<code>splitAt</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nsplitAt :: Int [T] =&gt; ([T], [T])\nsplitAt    idx ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Splits the list into two smaller lists at position <code>idx</code>. The element at position <code>idx</code> moves to the second list.</p> <p>The position starts from zero.</p> <p>Usage</p> <pre><code>// CLEAN\n\nsplitAt   2  [1, 2]  // ([1, 2], [])\nsplitAt   1  [1, 2]  // ([1], [2])\nsplitAt   0  [1, 2]  // ([], [1, 2])\nsplitAt (-1) [1, 2]  // ([1, 2], [])\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#indexlist","title":"<code>indexList</code>","text":"<p>Signature</p> <pre><code>// Clean\n\nindexList :: [T] -&gt; [Int]\nindexList    ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns a list of indexes equal to the length of the list. If the given list is empty, returns an empty list.</p> <p>Usage</p> <pre><code>// CLEAN\n\nindexList [3, 2, 1]  // [0, 1, 2]\nindexList [1, 2]     // [0, 1]\nindexList [2]        // [0]\nindexList []         // []\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#repeat","title":"<code>repeat</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nrepeat T -&gt; [T]\nrepeat e =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns a list of containing infinitely many of the given element <code>e</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nrepeat 0     // [0, 0, 0, ...]\nrepeat 1.0   // [1.0, 1.0, 1.0, ...]\nrepeat 'a'   // ['a', 'a', 'a', ...] \nrepeat True  // [True, True, True, ...]\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#repeatn","title":"<code>repeatn</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nrepeatn :: Int T -&gt; [T]\nrepeat     cnt e =&gt; ...\n</code></pre> <p>Behavior</p> <p>Generates a list of length <code>cnt</code> contain a single element <code>e</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nrepeatn 0 0     // []\nrepeatn 1 1.0   // [1.0]\nrepeatn 2 'a'   // ['a', 'a'] \nrepeatn 3 True  // [True, True, True]\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#ismember","title":"<code>isMember</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisMember :: T [T] -&gt; Bool | == T\nisMember    e ls  =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Equality</code> class from <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Returns true if the list contains the given element. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisMember 4 [1, 2, 3]  // False\nisMember 2 [1, 2, 3]  // True\nisMember 1 []         // False\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#isanymember","title":"<code>isAnyMember</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisAnyMember :: [T] [T] -&gt; Bool | == T\nisAnyMember    lsA lsB =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Equality</code> class from <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Returns true if at least one element of the list <code>lsB</code> is an element of the list <code>lsA</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisAnyMember [1, 2] [1, 2]  // True\nisAnyMember [1, 2] [1]     // True\nisAnyMember [1, 2] [3, 4]  // False\nisAnyMember [1, 2] []      // False\nisAnyMember [] [1, 2]      // False\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#removedup","title":"<code>removeDup</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nremoveDup :: [T] -&gt; [T] | == T\nremoveDup    ls  =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the class <code>Equality</code> from the <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Removes duplicate elements from the given list. Only the first occurrence of each element and discard other occurrences.</p> <p>Usage</p> <pre><code>// CLEAN\n\nremoveDup [1, 2, 2, 3]  // [1, 2, 3]\nremoveDup [1, 2, 3, 4]  // [1, 2, 3, 4]\nremoveDup []            // []\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#removemember","title":"<code>removeMember</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nremoveMember :: T [T] -&gt; [T] | == T\nremoveMember    e ls  =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Equality</code> class from <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Removes the first occurrence of the given element from the list.</p> <p>Usage</p> <pre><code>// CLEAN\n\nremoveMember 4 [1, 2, 2, 3]  // [1, 2, 2, 3]\nremoveMember 2 [1, 2, 2, 3]  // [1, 2, 3]\nremoveMember 1 [1, 2, 2, 3]  // [2, 2, 3]\nremoveMember 0 []            // []\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#removemembers","title":"<code>removeMembers</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nremoveMember :: [T] [T] -&gt; [T] | == T\nremoveMember    oLs rLs  =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Equality</code> class from <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Removes the first occurrence of each element in the list <code>rLs</code> from the list <code>oLs</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nremoveMembers [1, 2, 3] []  // [1, 2, 3]\nremoveMembers [2, 3] [1]    // [2, 3]\nremoveMembers [1, 1] [1]    // [1]\nremoveMembers [] [1, 2]     // []\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#removeindex","title":"<code>removeIndex</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nremoveIndex :: T [T] -&gt; (Int, [T]) | == T\nremoveIndex    e ls  =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Equality</code> class from the <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Removes the first occurrence of the given element <code>e</code> from the list <code>ls</code>, then returns its index and the modified list.</p> <p>Results in a run-time error the list does not contain the given element.</p> <pre><code>$ Error in removeIndex: element not found\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\nremoveIndex 2 [1, 2, 2, 3]  // (1, [1, 2, 3])\nremoveIndex 1 [1, 2, 2, 3]  // (0, [2, 2, 3])\nremoveIndex 3 [1, 2, 2, 3]  // (2, [1, 2, 2])\nremoveIndex 4 [1, 2, 2, 3]  // run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#sum","title":"<code>sum</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nsum :: [T] -&gt; T | (+ T) &amp; (zero T)\nsum    ls  =&gt; ... \n</code></pre> <p>The type <code>T</code> must be an instance of the <code>zero</code> and <code>Addition</code> class from <code>StdOverloaded</code>.</p> <p>Behavior</p> <p>Returns the sum of the list.</p> <p>Under the hood, the function adds every element together using the defined addition operation and zero unit on the type <code>T</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nsum [1, 2, 3, 4]  // 10\nsum [1, 2, 3]     // 6\nsum [1, 2]        // 3\nsum [1]           // 1\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#prod","title":"<code>prod</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nprod :: [T] -&gt; T | (+ T) &amp; (zero T)\nprod    ls  =&gt; ... \n</code></pre> <p>The type <code>T</code> must be an instance of the <code>one</code> and <code>Multiplication</code> class from <code>StdOverloaded</code>.</p> <p>Behavior</p> <p>Returns the product of the list.</p> <p>Under the hood, the function multiplies every element together using the defined multiplication operation and one unit on the type <code>T</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nprod [1, 2, 3, 4]  // 24\nprod [1, 2, 3]     // 6\nprod [1, 2]        // 3\nprod [1]           // 1\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#avg","title":"<code>avg</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\navg :: [T] -&gt; T | (IncDec T) &amp; (/ T)\navg    ls  =&gt; ... \n</code></pre> <p>The type <code>T</code> must be an instance of the <code>IncDec</code> class from <code>StdClass</code> module and the <code>Division</code> class from <code>StdOverloaded</code>.</p> <p>Behavior</p> <p>Returns the average of the list.</p> <p>Under the hood, the function adds every element together using the defined addition operation and zero unit on the type <code>T</code>, then it divides the sum by the length of the list.</p> <p>Results in a run-time error if the given list is empty.</p> <pre><code>$ avg called with empty list\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\navg [1, 2, 3, 4]  // 2\navg [1, 2, 3]     // 2\navg [1, 2]        // 1\navg [1]           // 1\navg []            // run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#and","title":"<code>and</code>","text":"<p>Signature</p> <pre><code>// CLEAn\n\nand :: [Bool] -&gt; Bool\nand    bLs    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if every element in the given list is true. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nand [False, False]  // False\nand [False, True]   // True\nand [True, True]    // True\nand [False]         // False\nand [True]          // True\nand []              // True\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#or","title":"<code>or</code>","text":"<p>Signature</p> <pre><code>// CLEAn\n\nor :: [Bool] -&gt; Bool\nor    bLs    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if at least one element in the given list is true. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nor [False, False]  // False\nor [False, True]   // True\nor [True, True]    // True\nor [False]         // False\nor [True]          // True\nor []              // False\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#higher-order-functions","title":"Higher-order functions","text":"<p>These are functions which accepts a list and another functions as arguments. They provided a similar functionality to their basic counterpart but with additional flexibility.</p>"},{"location":"the-stdenv-module/stdlist/#takewhile","title":"<code>takeWhile</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\ntakeWhile :: (T -&gt; Bool) [T] -&gt; [T]\ntakeWhile    predicate   ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>It performs the <code>predicate</code> on each element of the given list starting from the left.</p> <p>If the predicate returns true for an element, it will be collected into the result.</p> <p>If the predicate returns false for an element, the function stops and returns the element it has collected so far.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntakeWhile isOdd  [1, 1, 1]  // [1, 1, 1]\ntakeWhile isOdd  [1, 2, 3]  // [1]\ntakeWhile isEven [1, 2, 3]  // []\ntakeWhile isOdd  []         // []\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#dropwhile","title":"<code>dropWhile</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\ndropWhile :: (T -&gt; Bool) [T] -&gt; [T]\ndropWhile    predicate   ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>It performs the <code>predicate</code> on each element of the given list starting from the left.</p> <p>If the predicate returns true for an element, it will be discarded.</p> <p>If the predicate returns false for an element, the function stops and the rest of the list.</p> <p>Usage</p> <pre><code>// CLEAN\n\ndropWhile isOdd  [1, 1, 1]  // []\ndropWhile isOdd  [1, 2, 3]  // [2, 3]\ndropWhile isEven [1, 2, 3]  // [1, 2, 3]\ndropWhile isOdd  []         // []\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#filter","title":"<code>filter</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nfilter :: (T -&gt; Bool) [T] -&gt; [T]\nfilter    predicate   ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Filters the list using the given predicate, keeping only the element which yields true.</p> <p>Usage</p> <pre><code>// CLEAN\n\nfilter isEven [2, 3, 4]  // [2, 4]\nfilter isEven [1, 2, 3]  // [2, 3]\nfilter isOdd  [1, 2, 3]  // [1]\nfilter isOdd  [2, 3, 4]  // [3]\nfilter isOdd  []         // []\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#foldr","title":"<code>foldr</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nfoldr :: (T -&gt; K -&gt; K) K [T] -&gt; K\nfoldr    func          s ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Folds the list from left to right using the given <code>func</code>. The starting value is determined by the argument <code>s</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nfoldr (+) 0 [1, 2, 3]  // 1 + (2 + (3 + 0))\nfoldr (+) 0 [3, 2, 1]  // 3 + (2 + (1 + 0))\nfoldr (^) 1 [1, 2, 3]  // 1 ^ (2 ^ (3 ^ 1))\nfoldr (^) 1 [3, 2, 1]  // 3 ^ (2 ^ (1 ^ 1))\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#foldl","title":"<code>foldl</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nfoldl :: (K -&gt; T -&gt; K) K [T] -&gt; T\nfoldl    func          s ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Folds the list from right to left using the given <code>func</code>. The starting value is determined by the argument <code>s</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nfoldl (+) 0 [1, 2, 3]  // ((0 + 1) + 2) + 3\nfoldr (+) 0 [3, 2, 1]  // ((0 + 3) + 2) + 1\nfoldl (^) 1 [1, 2, 3]  // ((1 ^ 1) ^ 2) ^ 3\nfoldl (^) 1 [3, 2, 1]  // ((1 ^ 3) ^ 2) ^ 1\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#iterate","title":"<code>iterate</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\niterate :: (T -&gt; T) T -&gt; [T]\niterate    func     e =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns an infinite list by repeatedly apply the <code>func</code> to <code>e</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\niterate ((+) 1) 0  // [0, 1, 2, ...]\niterate ((*) 2) 1  // [1, 2, 4, ...]\niterate toInt   1  // [1, 1, 1, ...]\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#map","title":"<code>map</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nmap :: (T -&gt; K) [T] -&gt; [K]\nmap    func     ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Applies the function <code>func</code> to every element of the given list.</p> <p>Usage</p> <pre><code>// CLEAN\n\nmap isEven  [1, 2, 3]  // [False, True, False]\nmap toReal  [1, 2, 3]  // [1.0, 2.0, 3.0]\nmap ((+) 2) [1, 2, 3]  // [3, 4, 5]\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#scan","title":"<code>scan</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nscan :: (T -&gt; K -&gt; T) T [K] -&gt; [T]\nscan    func          e ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Generates a list of reduced values from apply the function <code>func</code> to elements in the given list.</p> <p>Usage</p> <pre><code>// CLEAN\n\nscan (+) 0 [1, 2, 3]\n// [0, 0 + 1, (0 + 1) + 2, ((0 + 1) + 2) + 3]\n// [0, 1, 3, 6]\n\nscan (+) 0 [3, 2, 1]\n// [0, 0 + 3, (0 + 3) + 2, ((0 + 3) + 2) + 1]\n// [0, 3, 5, 6]\n\nscan (^) 1 [1, 2, 3]\n// [1, 1 ^ 1, (1 ^ 1) ^ 2, ((1 ^ 1) ^ 2) ^ 3]\n// [1, 1, 1, 1]\n\nscan (^) 1 [3, 2, 1]\n// [1, 1 ^ 3, (1 ^ 3) ^ 2, ((1 ^ 3) ^ 2) ^ 1]\n// [1, 1, 1, 1]\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#all","title":"<code>all</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nall :: (T -&gt; Bool) [T] -&gt; Bool\nall    predicate   ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Applies the function <code>predicate</code> to every element in the given list and returns true if at every element yields true. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nall isEven [1, 2, 3]  // False\nall isOdd  [1, 2, 3]  // False\nall isEven [2, 4, 6]  // True\nall isOdd  [1, 3, 5]  // True\nall isEven []         // True\nall isOdd  []         // True\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#any","title":"<code>any</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nany :: (T -&gt; Bool) [T] -&gt; Bool\nany    predicate   ls  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Applies the function <code>predicate</code> to every element in the given list and returns true if at least one element yields true. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nany isEven [1, 2, 3]  // True\nany isOdd  [1, 2, 3]  // True\nany isEven [1, 3, 5]  // False\nany isOdd  [2, 4, 6]  // False\nany isEven []         // False\nany isOdd  []         // False\n</code></pre>"},{"location":"the-stdenv-module/stdlist/#validator-functions","title":"Validator functions","text":"<p>The function is not so difficult to defined, but they are convenient to use.</p>"},{"location":"the-stdenv-module/stdlist/#isempty","title":"<code>isEmpty</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisEmpty :: [T] -&gt; Bool\nisEmpty    A   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the list is empty. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisEmpty []   // True\nisEmpty [1]  // False\n</code></pre>"},{"location":"the-stdenv-module/stdmisc/","title":"StdMisc","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module. As the name suggests, it provides definitions for miscellaneous functions you might need in your program. Though, they mostly concern with program termination.</p> <p>Visit StdMisc on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdmisc/#units","title":"Units","text":""},{"location":"the-stdenv-module/stdmisc/#undefined-entity","title":"Undefined Entity","text":"<p>Implementation</p> <pre><code>// CLEAN\n\nundef ::  anyType\nundef :== ...\n</code></pre> <p>Definition</p> <p>Represents an undefined value.</p> <p>Forces a program to terminate if it is ever evaluated. Under the hood, it invokes the <code>abort</code> function with a specific error message.</p>"},{"location":"the-stdenv-module/stdmisc/#functions","title":"Functions","text":""},{"location":"the-stdenv-module/stdmisc/#abort","title":"<code>abort</code>","text":"<p>Signature</p> <pre><code>abort :: {#Char} -&gt; anyType\nabort    errMsg  =&gt; ...\n</code></pre> <p>Behavior</p> <p>Terminates the program and return an error message <code>errMsh</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nabort \"Terminated\"  // \"Terminated\"\n</code></pre>"},{"location":"the-stdenv-module/stdordlist/","title":"StdOrdList","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module. It provides definitions for list-ordering functions.</p> <p>Visit StdOrdList on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdordlist/#basic-functions","title":"Basic functions","text":"<p>These functions are not too difficult to define, but they are convenient to use.</p>"},{"location":"the-stdenv-module/stdordlist/#sort","title":"<code>sort</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nsort :: [T] -&gt; [T] | Ord T\nsort    ls  =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Ord</code> class from the <code>StdClass</code> module.</p> <p>Behavior</p> <p>Sorts the list in ascending order. Under the hood, this function uses merge sort.</p> <p>Usage</p> <pre><code>// CLEAN\n\nsort [1, 1, 1]  // [1, 1, 1]\nsort [1, 2, 3]  // [1, 2, 3]\nsort [2, 1, 3]  // [1, 2, 3]\nsort []         // []\n</code></pre>"},{"location":"the-stdenv-module/stdordlist/#maxlist","title":"<code>maxList</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nmaxList :: [T] -&gt; T | Ord T\nmaxList    ls  =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Ord</code> class from the <code>StdClass</code> module.</p> <p>Behavior</p> <p>Returns the largest element of the list. Under the hood, this function uses the equality and less than operations to determine which element to return.</p> <p>Results in a run-time error if the given list is empty.</p> <pre><code>$ maxList of []\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\nmaxList [1, 1, 1]  // 1\nmaxList [1, 2, 3]  // 3\nmaxList []         // run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdordlist/#minlist","title":"<code>minList</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nminList :: [T] -&gt; T | Ord T\nminList    ls  =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Ord</code> class from the <code>StdClass</code> module.</p> <p>Behavior</p> <p>Returns the smallest element of the list. Under the hood, this function uses the equality and less than operations to determine which element to return.</p> <p>Results in a run-time error if the given list is empty.</p> <pre><code>$ minList of []\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\nminList [1, 1, 1]  // 1\nminList [1, 2, 3]  // 1\nminList []         // run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdordlist/#higher-order-functions","title":"Higher-order functions","text":""},{"location":"the-stdenv-module/stdordlist/#sortby","title":"<code>sortBy</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nsortBy :: (T -&gt; T -&gt; Bool) [T] -&gt; [T]\nsortBy    sortRule         ls  =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Ord</code> class from the <code>StdClass</code> module.</p> <p>Behavior</p> <p>Sorts the list based on the given <code>sortRule</code> function.</p> <p>Usage</p> <pre><code>// CLEAN\n\nsortBy (&gt;) [1, 1, 1]  // [1, 1, 1]\nsortBy (&gt;) [1, 2, 3]  // [3, 2, 1]\nsortBy (&gt;) [2, 1, 3]  // [3, 2, 1]\nsortby (&gt;) []         // []\n</code></pre>"},{"location":"the-stdenv-module/stdordlist/#maxlistby","title":"<code>maxListBy</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nmaxListBy :: (T -&gt; T -&gt; Bool) [T] -&gt; [T]\nmaxListBy    maxRule          ls  =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Ord</code> class from the <code>StdClass</code> module.</p> <p>Behavior</p> <p>Returns the largest element from the given list. The largest element is determined by the given <code>maxRule</code> function.</p> <p>Results in a run-time error if the given list is empty.</p> <pre><code>$ maxListBy of []\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\nmaxListBy (&lt;) [1, 2, 3]  // 3\nmaxListBy (&gt;) [1, 1, 1]  // 1\nmaxListBy (&gt;) [1, 2, 3]  // 1\nmaxListBy (&gt;) []         // run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdordlist/#minlistby","title":"<code>minListBy</code>","text":"<p>Signature </p> <pre><code>// CLEAN\n\nmaxListBy :: (T -&gt; T -&gt; Bool) [T] -&gt; [T]\nmaxListBy    minRule          ls  =&gt; ...\n</code></pre> <p>The type <code>T</code> must be an instance of the <code>Ord</code> class from the <code>StdClass</code> module.</p> <p>Behavior</p> <p>Returns the smallest element from the given list. The smallest element is determined by the given <code>minRule</code> function.</p> <p>Results in a run-time error if the given list is empty.</p> <pre><code>$ minListBy of []\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\nminListBy (&lt;) [1, 2, 3]  // 1\nminListBy (&gt;) [1, 1, 1]  // 1\nminListBy (&gt;) [1, 2, 3]  // 3\nminListBy (&gt;) []         // run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdoverloaded/","title":"StdOverloaded","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module. It provides definitions for important classes in CLEAN.</p> <p>Visit StdOverloaded on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdoverloaded/#unit-classes","title":"Unit classes","text":""},{"location":"the-stdenv-module/stdoverloaded/#zero","title":"<code>zero</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass zero T\nwhere\n    zero :: T\n</code></pre> <p>Definition</p> <p>Defines the additive identity on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#one","title":"<code>one</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass one T\nwhere\n    one :: T\n</code></pre> <p>Definition</p> <p>Defines the multiplicative identity on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#manipulation-operation-classes","title":"Manipulation operation classes","text":""},{"location":"the-stdenv-module/stdoverloaded/#negation","title":"Negation","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass ~ T\nwhere\n    ~ :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the negation operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#slicing","title":"Slicing","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass % T\nwhere\n    (%) infixl 9 :: T (Int, Int) -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the slicing operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#concatenation","title":"Concatenation","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass +++ T\nwhere\n    (+++) infixl 5 :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the concatenation operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#math-operation-classes","title":"Math operation classes","text":""},{"location":"the-stdenv-module/stdoverloaded/#addition","title":"Addition","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass + T\nwhere\n    (+) infixl 6 :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the addition operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#subtraction","title":"Subtraction","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass + T\nwhere\n    (-) infixl 6 :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the subtraction operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#multiplication","title":"Multiplication","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass * T\nwhere\n    (*) infixl 7 :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the multiplication operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#division","title":"Division","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass / T\nwhere\n    (/) infixl 7 :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the division operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#reminder-division","title":"Reminder division","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass rem T\nwhere\n    (rem) infixl 7 :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the reminder division operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#modulo","title":"Modulo","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass mod T\nwhere\n    (mod) infixl 7 :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the modulo operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#exponentiation","title":"Exponentiation","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass ^ T\nwhere\n    (^) infixl 7 :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the exponentiation operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#math-function-classes","title":"Math function classes","text":""},{"location":"the-stdenv-module/stdoverloaded/#inc","title":"<code>inc</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass inc T\nwhere\n    inc :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines unit increment on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#dec","title":"<code>dec</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass dec T\nwhere\n    dec :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines unit decrement on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#gcd","title":"<code>gcd</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass gcd T\nwhere\n    gcd :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the greatest common divisor operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#lcm","title":"<code>lcm</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass lcm T\nwhere\n    lcm :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the least common multiple operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#abs","title":"<code>abs</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass abs T\nwhere\n    abs :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the absolute value function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#sign","title":"<code>sign</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass sign T\nwhere\n    sign :: T -&gt; Int\n</code></pre> <p>Definition</p> <p>Defines the sign function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#ln","title":"<code>ln</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass ln T\nwhere\n    ln :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the natural logarithm function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#exp","title":"<code>exp</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass exp T\nwhere\n    exp :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the exponential function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#sqrt","title":"<code>sqrt</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass sqrt T\nwhere\n    sqrt :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the square root function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#log10","title":"<code>log10</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass log10 T\nwhere\n    log10 :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the base-ten logarithm function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#trigonometric-function-classes","title":"Trigonometric function classes","text":""},{"location":"the-stdenv-module/stdoverloaded/#sin","title":"<code>sin</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass sin T\nwhere\n    sin :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the sine function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#cos","title":"<code>cos</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass cos T\nwhere\n    cos :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the cosine function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#tan","title":"<code>tan</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass tan T\nwhere\n    tan :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the tangent function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#asin","title":"<code>asin</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass asin T\nwhere\n    asin :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the inverse of sine function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#acos","title":"<code>acos</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass acos T\nwhere\n    acos :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the inverse of cosine function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#atan","title":"<code>atan</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass atan T\nwhere\n    atan :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the inverse of tangent function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#sinh","title":"<code>sinh</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass sinh T\nwhere\n    sinh :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the hyperbolic sine function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#cosh","title":"<code>cosh</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass cosh T\nwhere\n    cosh :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the hyperbolic cosine function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#tanh","title":"<code>tanh</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass tanh T\nwhere\n    tanh :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the hyperbolic tangent function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#asinh","title":"<code>asinh</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass asinh T\nwhere\n    asinh :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the inverse of hyperbolic sine function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#acosh","title":"<code>acosh</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass acosh T\nwhere\n    acosh :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the inverse of hyperbolic cosine function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#atanh","title":"<code>atanh</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass atanh T\nwhere\n    atanh :: T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the inverse of hyperbolic tangent function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#validator-function-classes","title":"Validator function classes","text":""},{"location":"the-stdenv-module/stdoverloaded/#iseven","title":"<code>isEven</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass isEven T\nwhere\n    isEven :: T -&gt; Bool\n</code></pre> <p>Definition</p> <p>Defines the <code>isEven</code> function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#isodd","title":"<code>isOdd</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass isOdd T\nwhere\n    isOdd :: T -&gt; Bool\n</code></pre> <p>Definition</p> <p>Defines the <code>isOdd</code> function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#property-function-classes","title":"Property function classes","text":""},{"location":"the-stdenv-module/stdoverloaded/#length","title":"<code>length</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass length T\nwhere\n    length :: (T a) -&gt; Int\n</code></pre> <p>Definition</p> <p>Defines the <code>length</code> function on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#type-conversion-function-classes","title":"Type conversion function classes","text":""},{"location":"the-stdenv-module/stdoverloaded/#toint","title":"<code>toInt</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass toInt T\nwhere\n    toInt :: T -&gt; Int\n</code></pre> <p>Definition</p> <p>Defines conversion from type <code>T</code> to integer.</p>"},{"location":"the-stdenv-module/stdoverloaded/#toreal","title":"<code>toReal</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass toReal T\nwhere\n    toReal :: T -&gt; Real\n</code></pre> <p>Definition</p> <p>Defines conversion from type <code>T</code> to real numbers.</p>"},{"location":"the-stdenv-module/stdoverloaded/#tochar","title":"<code>toChar</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass toChar T\nwhere\n    toChar :: T -&gt; Char\n</code></pre> <p>Definition</p> <p>Defines conversion from type <code>T</code> to character.</p>"},{"location":"the-stdenv-module/stdoverloaded/#tobool","title":"<code>toBool</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass toBool T\nwhere\n    toBool :: T -&gt; Bool\n</code></pre> <p>Definition</p> <p>Defines conversion from type <code>T</code> to Boolean.</p>"},{"location":"the-stdenv-module/stdoverloaded/#tostring","title":"<code>toString</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass toString T\nwhere\n    toString :: T -&gt; String\n</code></pre> <p>Definition</p> <p>Defines conversion from type <code>T</code> to string.</p>"},{"location":"the-stdenv-module/stdoverloaded/#fromint","title":"<code>fromInt</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass fromInt T\nwhere\n    fromInt :: Int -&gt; T\n</code></pre> <p>Definition</p> <p>Defines conversion from integer to type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#fromreal","title":"<code>fromReal</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass fromReal T\nwhere\n    fromReal :: Real -&gt; T\n</code></pre> <p>Definition</p> <p>Defines conversion from real number to type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#fromchar","title":"<code>fromChar</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass fromChar T\nwhere\n    fromChar :: Char -&gt; T\n</code></pre> <p>Definition</p> <p>Defines conversion from character to type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#frombool","title":"<code>fromBool</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass fromBool T\nwhere\n    fromBool :: Bool -&gt; T\n</code></pre> <p>Definition</p> <p>Defines conversion from Boolean to type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#fromstring","title":"<code>fromString</code>","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass fromString T\nwhere\n    fromString :: String -&gt; T\n</code></pre> <p>Definition</p> <p>Defines conversion from string to type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#relational-operation-classes","title":"Relational operation classes","text":""},{"location":"the-stdenv-module/stdoverloaded/#equality","title":"Equality","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass == T\nwhere\n    (==) infixl 4 :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the equality operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdoverloaded/#less-than","title":"Less than","text":"<p>Declaration</p> <pre><code>// CLEAN\n\nclass &lt; T\nwhere\n    (&lt;) infixl 4 :: T T -&gt; T\n</code></pre> <p>Definition</p> <p>Defines the less than operation on type <code>T</code>.</p>"},{"location":"the-stdenv-module/stdreal/","title":"StdReal","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module. It provides definition for many critical operations and functions on real numbers.</p> <p>Visit StdReal on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdreal/#units","title":"Units","text":"<p>The real number units follow their definitions in mathematics.</p>"},{"location":"the-stdenv-module/stdreal/#zero","title":"Zero","text":"<p>Implementation</p> <pre><code>// CLEAN\n\nzero ::  Real\nzero :== 0.0\n</code></pre> <p>Definition</p> <p>Represents the additive identity of real numbers.</p>"},{"location":"the-stdenv-module/stdreal/#one","title":"One","text":"<p>Implementation</p> <pre><code>// CLEAN\n\none ::  Real\none :== 1.0\n</code></pre> <p>Definition</p> <p>Represents the multiplicative identity of real numbers.</p>"},{"location":"the-stdenv-module/stdreal/#infinity","title":"Infinity","text":"<p>Implementation</p> <pre><code>// CLEAN\n\nInfinity ::  Real\nInfinity :== 1E9999\n</code></pre> <p>Definition</p> <p>Represents numerical values which are too large for CLEAN represent.</p>"},{"location":"the-stdenv-module/stdreal/#not-a-number","title":"Not-a-number","text":"<p>Implementation</p> <pre><code>// CLEAN\n\nNaN ::  Real\nNaN :== 1E9999 + (-1E9999)\n</code></pre> <p>Definition</p> <p>Represents numerical values which cannot be represented by CLEAN.</p> <p>See NaN for additional information.</p>"},{"location":"the-stdenv-module/stdreal/#math-operations","title":"Math operations","text":"<p>The definition and behavior of these operators follow their mathematic counterpart.</p> <p>It is worth noting that, natively, these operations only work with real number operands, but the programmer can define additional behaviors and functionalities.</p>"},{"location":"the-stdenv-module/stdreal/#addition","title":"Addition","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(+) infixl 6 :: Real Real -&gt; Real\n(+)             a    b    =  ...\n</code></pre> <p>Behavior</p> <p>Adds <code>a</code> and <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  2.5  +   1.5   //  4.0\n  2.5  + (-1.5)  //  1.5\n(-2.5) +   1.5   // -1.0\n(-2.5) + (-1.5)  // -4.0\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#subtraction","title":"Subtraction","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(-) infixl 6 :: Real Real -&gt; Real\n(-)             a    b    =  ...\n</code></pre> <p>Behavior</p> <p>Subtracts <code>b</code> from <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  2.5  -   1.5   //  1.0\n  2.5  - (-1.5)  //  4.0\n(-2.5) -   1.5   // -1.5\n(-2.5) - (-1.5)  // -1.0\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#multiplication","title":"Multiplication","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(*) infixl 7 :: Real Real -&gt; Real\n(*)             a    b    =  ...\n</code></pre> <p>Behavior</p> <p>Multiplies <code>a</code> with <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  2.5  *   1.5   //  3.75\n  2.5  * (-1.5)  // -3.75\n(-2.5) *   1.5   // -3.75\n(-2.5) * (-1.5)  //  3.75\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#division","title":"Division","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(/) infixl 7 :: Real Real -&gt; Real\n(/)             a    b    =  ...\n</code></pre> <p>Behavior</p> <p>Divides <code>a</code> with <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  2.5  /   1.5   //  1.66666666666667\n  2.5  / (-1.5)  // -1.66666666666667\n(-2.5) /   1.5   // -1.66666666666667\n(-2.5) / (-1.5)  //  1.66666666666667\n  1.0  /   0.0   //  #INF\n(-1.0) /   0.0   // -#INF\n  0.0  /   0.0   //  #NaN\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#exponentiation","title":"Exponentiation","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(^) infixr 8 :: Real Real -&gt; Real\n(^)             a    b    =  ...\n</code></pre> <p>Behavior</p> <p>Raises <code>a</code> to the power of <code>b</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  2.5  ^   1.5   //  3.95284707521047\n  2.5  ^ (-1.5)  //  0.25298221281347\n(-2.5) ^   1.5   //  #NAN\n(-2.5) ^ (-1.5)  //  #NAN\n  0.0  ^   0.0   //  1.0\n  0.0  ^   1.0   //  0.0\n  0.0  ^ (-1.0)  //  #INF\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#math-functions","title":"Math functions","text":"<p>This function is a unary operator, but there is no such thing as a unary operator in CLEAN, so to keep things tidy, I have decided to place it here.</p>"},{"location":"the-stdenv-module/stdreal/#negation","title":"Negation","text":"<p>Signature</p> <pre><code>// CLEAN\n\n~ :: Real -&gt; Real\n~    a    =  ...\n</code></pre> <p>Behavior</p> <p>Inverts the sign of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n~  1.0   // -1.0\n~  0.0   //  0.0\n~(-1.0)  //  1.0\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#sign","title":"<code>sign</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nsign :: Real -&gt; Int\nsign    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the sign of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nsign   1.0   //  1\nsign   0.0   //  0\nsign (-1.0)  // -1\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#abs","title":"<code>abs</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nabs :: Real -&gt; Real\nabs    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the absolute value of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nabs   1.0   // 1.0\nabs   0.0   // 0.0\nabs (-1.0)  // 1.0\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#ln","title":"<code>ln</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nln :: Real -&gt; Real\nln    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the natural logarithm of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nln   2.5   //  0.916290731874155\nln   1.5   // -1.405465108108164\nln   0.0   // -#INF\nln (-1.5)  //  #NAN\nln (-2.5)  //  #NAN\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#log10","title":"<code>log10</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nlog10 :: Real -&gt; Real\nlog10    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the logarithm base ten of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nlog10   2.5   //  0.397940008672038\nlog10   1.5   // -0.176091259055681\nlog10   0.0   // -#INF\nlog10 (-1.5)  //  #NAN\nlog10 (-2.5)  //  #NAN\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#exp","title":"<code>exp</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nexp :: Real -&gt; Real\nexp    a    =  ...\n</code></pre> <p>Behavior</p> <p>Raises \\(e\\) to the power of <code>a</code>.</p> <p>See Euler's number.</p> <p>Usage</p> <pre><code>// CLEAN\n\nexp   2.5   // 12.1824939607035\nexp   1.5   //  4.48168907033806\nexp   0.0   //  1.0\nexp (-1.5)  //  0.22313016014843\nexp (-2.5)  //  0.0820849986238988\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#sqrt","title":"<code>sqrt</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nsqrt :: Real -&gt; Real\nsqrt    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the square root of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nsqrt   2.5   // 1.58113883008419\nsqrt   1.5   // 1.22474487139159\nsqrt   0.0   // 0.0\nsqrt (-1.5)  // #NAN\nsqrt (-2.5)  // #NAN\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#relational-operations","title":"Relational operations","text":"<p>Equality comparison between two real numbers seems to be unaffected by rounding errors.</p>"},{"location":"the-stdenv-module/stdreal/#equal-to","title":"Equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(==) infix 4 :: Real Real -&gt; Bool\n(==)            a    b    =  ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is equal to <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5.0  ==   2.0   // False\n(-5.0) ==   2.0   // False\n  5.0  == (-2.0)  // False\n(-5.0) == (-2.0)  // False\n(-2.0) == (-2.0)  // True\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#not-equal-to","title":"Not equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;&gt;) infix 4 :: Real Real -&gt; Bool\n(&lt;&gt;)            a    b    =  ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is not equal to <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5.0  &lt;&gt;   2.0   // True\n(-5.0) &lt;&gt;   2.0   // True\n  5.0  &lt;&gt; (-2.0)  // True\n(-5.0) &lt;&gt; (-2.0)  // True\n(-2.0) &lt;&gt; (-2.0)  // False\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#less-than","title":"Less than","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;) infix 4 :: Real Real -&gt; Bool\n(&lt;)            a    b    =  ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is strictly less than <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5.0  &lt;   2.0   // False\n(-5.0) &lt;   2.0   // True\n  5.0  &lt; (-2.0)  // False\n(-5.0) &lt; (-2.0)  // True\n(-2.0) &lt; (-2.0)  // False\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#less-than-or-equal-to","title":"Less than or equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;=) infix 4 :: Real Real -&gt; Bool\n(&lt;=)            a    b    =  ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is less than or equal to <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5.0  &lt;=   2.0   // False\n(-5.0) &lt;=   2.0   // True\n  5.0  &lt;= (-2.0)  // False\n(-5.0) &lt;= (-2.0)  // True\n(-2.0) &lt;= (-2.0)  // True\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#greater-than","title":"Greater than","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&gt;) infix 4 :: Real Real -&gt; Bool\n(&gt;)            a    b    =  ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is strictly greater than <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5.0  &gt;   2.0   // True\n(-5.0) &gt;   2.0   // False\n  5.0  &gt; (-2.0)  // True\n(-5.0) &gt; (-2.0)  // False\n(-2.0) &gt; (-2.0)  // False\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#greater-than-or-equal-to","title":"Greater than or equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&gt;=) infix 4 :: Real Real -&gt; Bool\n(&gt;=)            a    b    =  ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is greater than or equal to <code>b</code>. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n  5.0  &gt;=   2.0   // True\n(-5.0) &gt;=   2.0   // False\n  5.0  &gt;= (-2.0)  // True\n(-5.0) &gt;= (-2.0)  // False\n(-2.0) &gt;= (-2.0)  // True\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#trigonometric-functions","title":"Trigonometric Functions","text":""},{"location":"the-stdenv-module/stdreal/#sin","title":"<code>sin</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nsin :: Real -&gt; Real\nsin    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the sine of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nsin   2.5   //  0.598472144103956\nsin   1.5   //  0.997494986604054\nsin   0.0   //  0.0\nsin (-1.5)  // -0.997494986604054\nsin (-2.5)  // -0.598472144103956\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#cos","title":"<code>cos</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\ncos :: Real -&gt; Real\ncos    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the cosine of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\ncos   2.5   // -0.801143615546934\ncos   1.5   //  0.0707372016677029\ncos   0.0   //  1.0\ncos (-1.5)  //  0.0707372016677029\ncos (-2.5)  // -0.801143615546934\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#tan","title":"<code>tan</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\ntan :: Real -&gt; Real\ntan    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the tangent of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntan   2.5   // - 0.74702229723866\ntan   1.5   //  14.1014199471717\ntan   0.0   //   0.0\ntan (-1.5)  // -14.1014199471717\ntan (-2.5)  //   0.74702229723866\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#asin","title":"<code>asin</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nasin :: Real -&gt; Real\nasin    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the inverse sine of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nasin   2.5   //  #NAN\nasin   1.5   //  #NAN\nasin   0.5   //  0.523598775598299\nasin   0.0   //  0.0\nasin (-0.5)  // -0.523598775598299\nasin (-1.5)  //  #NAN\nasin (-2.5)  //  #NAN\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#acos","title":"<code>acos</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nacos :: Real -&gt; Real\nacos    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the inverse cosine of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nacos   2.5   // #NAN\nacos   1.5   // #NAN\nacos   0.5   // 1.0471975511966\nacos   0.0   // 1.5707963267949\nacos (-0.5)  // 2.0943951023932\nacos (-1.5)  // #NAN\nacos (-2.5)  // #NAN\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#atan","title":"<code>atan</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\natan :: Real -&gt; Real\natan    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the inverse tangent of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\natan   2.5   //  1.19028994968253\natan   1.5   //  0.982793723247329\natan   0.5   //  0.463647609000806\natan   0.0   //  0.0\natan (-0.5)  // -0.463647609000806\natan (-1.5)  // -0.982793723247329\natan (-2.5)  // -1.19028994968253\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#sinh","title":"<code>sinh</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nsinh :: Real -&gt; Real\nsinh    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the hyperbolic sine of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nsinh   2.5   //  6.05020448103979\nsinh   1.5   //  2.12927945509482\nsinh   0.5   //  0.521095305493747\nsinh   0.0   //  0.0\nsinh (-0.5)  // -0.521095305493747\nsinh (-1.5)  // -2.12927945509482\nsinh (-2.5)  // -6.05020448103979\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#cosh","title":"<code>cosh</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\ncosh :: Real -&gt; Real\ncosh    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the hyperbolic cosine of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\ncosh   2.5   //  6.13228947966369\ncosh   1.5   //  2.35240961524325\ncosh   0.5   //  1.12762596520638\ncosh   0.0   //  1.0\ncosh (-0.5)  // -1.12762596520638\ncosh (-1.5)  // -2.35240961524325\ncosh (-2.5)  // -6.13228947966369\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#tanh","title":"<code>tanh</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\ntanh :: Real -&gt; Real\ntanh    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the hyperbolic tangent of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntanh   2.5   //  0.98661429815143\ntanh   1.5   //  0.905148253644866\ntanh   0.5   //  0.46211715726001\ntanh   0.0   //  0.0\ntanh (-0.5)  // -0.46211715726001\ntanh (-1.5)  // -0.905148253644866\ntanh (-2.5)  // -0.98661429815143\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#asinh","title":"<code>asinh</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nasinh :: Real -&gt; Real\nasinh    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the inverse hyperbolic sine of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nasinh   2.5   //  1.6472311463711\nasinh   1.5   //  1.19476321728711\nasinh   0.5   //  0.481211825059604\nasinh   0.0   //  0.0\nasinh (-0.5)  // -0.481211825059604\nasinh (-1.5)  // -1.19476321728711\nasinh (-2.5)  // -1.6472311463711\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#acosh","title":"<code>acosh</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nacosh :: Real -&gt; Real\nacosh    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the inverse hyperbolic cosine of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nacosh   2.5   // 1.56679923697241\nacosh   1.5   // 0.962423650119207\nacosh   0.5   // #NAN\nacosh   0.0   // #NAN\nacosh (-0.5)  // #NAN\nacosh (-1.5)  // #NAN\nacosh (-2.5)  // #NAN\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#atanh","title":"<code>atanh</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\natanh :: Real -&gt; Real\natanh    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns the inverse hyperbolic tangent of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\natanh   2.5   //  #NAN\natanh   1.5   //  #NAN\natanh   0.5   //  0.549306144334055\natanh   0.0   //  0.0\natanh (-0.5)  // -0.549306144334055\natanh (-1.5)  //  #NAN\natanh (-2.5)  //  #NAN\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#validator-functions","title":"Validator functions","text":""},{"location":"the-stdenv-module/stdreal/#isnan","title":"<code>isNaN</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisNaN :: Real -&gt; Bool\nisNaN    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is a <code>NaN</code> value. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisNaN  2.0               // False\nisNaN  0.0               // False\nisNaN (sqrt (-1.0))      // True\nisNaN (ln   (-1.0))      // True\nisNaN ((-1.0) /   0.0)   // False\nisNaN (  0.0  ^ (-1.0))  // False\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#isinfinity","title":"<code>isInfinity</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisInfinity :: Real -&gt; Bool\nisInfinity    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is an <code>Infinity</code> value. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisInfinity 2.0                // False\nisInfinity 0.0                // False\nisInfinity (sqrt (-1.0))      // False\nisInfinity (ln   (-1.0))      // False\nisInfinity ((-1.0) /   0.0)   // True\nisInfinity (  0.0  ^ (-1.0))  // True\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#isfinite","title":"<code>isFinite</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nisFinite :: Real -&gt; Bool\nisFinite    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns true if <code>a</code> is representable. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\nisFinite 2.0                // True\nisFinite 0.0                // True\nisFinite (sqrt (-1.0))      // False\nisFinite (ln   (-1.0))      // False\nisFinite ((-1.0) /   0.0)   // False\nisFinite (  0.0  ^ (-1.0))  // False\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#conversions-to-real-number","title":"Conversions to real number","text":"<p>Natively, two types can convert to real numbers, namely, integers and strings.</p>"},{"location":"the-stdenv-module/stdreal/#from-integer","title":"From integer","text":"<p>Signature</p> <pre><code>// CLEAN\n\ntoReal :: Int -&gt; Real\ntoReal    a   =  ...\n</code></pre> <p>Behavior</p> <p>Sets the decimal places of <code>a</code> to 0.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntoReal   2   //  2.0\ntoReal   1   //  1.0\ntoReal   0   //  0.0\ntoReal (-1)  // -1.0\ntoReal (-2)  // -2.0\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#from-string","title":"From string","text":"<p>Signature</p> <pre><code>// CLEAN\n\ntoReal :: {#Char} -&gt; Real\ntoReal    a       =  ...\n</code></pre> <p>Behavior</p> <p>It parses <code>a</code> as a real number.</p> <p>Usage</p> <pre><code>// CLEAN\n\ntoReal \"1.0\"   //  1.0\ntoReal \"1\"     //  1.0\ntoReal \"0\"     //  0.0\ntoReal \"-1\"    // -1.0\ntoReal \"-1.0\"  //  1.0\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#conversions-from-real-number","title":"Conversions from real number","text":"<p>The function responsible for type conversion is overloaded, it has the same parameter but different return type, so to use it, the desired type must be unambiguous.</p>"},{"location":"the-stdenv-module/stdreal/#to-integer","title":"To integer","text":"<p>Signature</p> <pre><code>// CLEAN\n\nfromReal :: Real -&gt; Int\nfromReal    a    =  ...\n</code></pre> <p>Behavior</p> <p>Rounds <code>a</code> to its nearest integer.</p> <p>Usage</p> <pre><code>// CLEAN\n\nexpr :: Int\nexpr =  fromReal   1.9   //  2\nexpr =  fromReal   1.4   //  1\nexpr =  fromReal (-1.4)  // -1\nexpr =  fromReal (-1.9)  // -2\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#to-string","title":"To string","text":"<p>Signature</p> <pre><code>// CLEAN\n\nfromReal :: Real -&gt; {#Char}\nfromReal    a    =  ...\n</code></pre> <p>Behavior</p> <p>Returns a string representation of <code>a</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\nexpr :: {#Char}\nexpr =  fromReal   1.9   // \"1.9\"\nexpr =  fromReal   1.4   // \"1.4\"\nexpr =  fromReal (-1.4)  // \"-1.4\"\nexpr =  fromReal (-1.9)  // \"-1.9\"\n</code></pre>"},{"location":"the-stdenv-module/stdreal/#entier","title":"<code>entier</code>","text":"<p>Signature</p> <pre><code>// CLEAN\n\nentier :: Real -&gt; Int\nentier    a    =  ...\n</code></pre> <p>Behavior</p> <p>Rounds <code>a</code> down to its nearest integer.</p> <p>Usage</p> <pre><code>// CLEAN\n\nentier   1.5   //  1\nentier   0.0   //  0\nentier (-1.5)  // -2\n</code></pre>"},{"location":"the-stdenv-module/stdstring/","title":"StdString","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module. It provides useful definition for many critical interaction with strings.</p> <p>Visit StdString on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdstring/#basic-operations","title":"Basic operations","text":"<p>These operators provide ways to manipulate strings.</p> <p>Note that strings are simply arrays of characters, operations on arrays will work on strings also.</p>"},{"location":"the-stdenv-module/stdstring/#concatenation","title":"Concatenation","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(+++) infixr 5 :: {#Char} {#Char} -&gt; {#Char}\n(+++)             strL    strR    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Joins the string <code>strR</code> to the end of <code>strL</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n\"123\" +++ \"45\"  // \"12345\"\n\"123\" +++ \"4\"   // \"1234\"\n\"123\" +++ \"\"    // \"123\"\n</code></pre>"},{"location":"the-stdenv-module/stdstring/#slicing","title":"Slicing","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(%) infixl 9 :: {#Char} (Int, Int) -&gt; {#Char}\n(%)             strL    (l, r)     =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns characters which are inclusive between the position <code>l</code> and <code>r</code>.</p> <p>Usage</p> <pre><code>// CLEAN\n\n\"123\" % (  2,  4)  // \"3\"\n\"123\" % (  0,  2)  // \"123\"\n\"123\" % ((-1), 0)  // \"12\"\n\"123\" % ((-2), 5)  // \"123\"\n</code></pre>"},{"location":"the-stdenv-module/stdstring/#update","title":"Update","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(:=) infixl 9 :: {#Char} (Int, Char) -&gt; {#Char}\n(:=)             str     (idx, ch)   =&gt; ...\n</code></pre> <p>Behavior</p> <p>Overrides the character at the position <code>idx</code> with the given character <code>ch</code>.</p> <p>Results in a run-time error when over-indexing or under-indexing.</p> <pre><code>$ Index too high in UPDATE string.\n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\n\"abcde\" := (  5,  'X')  // run-time error\n\"abcde\" := (  2,  'C')  // \"abCde\"\n\"abcde\" := (  0,  'A')  // \"Abcde\"\n\"abcde\" := ((-1), 'A')  // run-time error\n</code></pre>"},{"location":"the-stdenv-module/stdstring/#relational-operations","title":"Relational operations","text":"<p>CLEAN performs pairwise to compare two strings. I recommend looking at the usage examples if the behavior is unclear.</p>"},{"location":"the-stdenv-module/stdstring/#equal-to","title":"Equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(==) infix 4 :: {#Char} {#Char} -&gt; Bool\n(==)            strL    strR    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the two strings are equal. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n\"\"   == \"\"    // True\n\"12\" == \"12\"  // True\n\"12\" == \"1\"   // False\n\"1\"  == \"12\"  // False\n\"12\" == \"13\"  // False\n\"13\" == \"12\"  // False\n</code></pre>"},{"location":"the-stdenv-module/stdstring/#not-equal-to","title":"Not equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;&gt;) infix 4 :: {#Char} {#Char} -&gt; Bool\n(&lt;&gt;)            strL    strR    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the two strings are not equal. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n\"\"   &lt;&gt; \"\"    // False\n\"12\" &lt;&gt; \"12\"  // False\n\"12\" &lt;&gt; \"1\"   // True\n\"1\"  &lt;&gt; \"12\"  // True\n\"12\" &lt;&gt; \"13\"  // True\n\"13\" &lt;&gt; \"12\"  // True\n</code></pre>"},{"location":"the-stdenv-module/stdstring/#less-than","title":"Less than","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;) infix 4 :: {#Char} {#Char} -&gt; Bool\n(&lt;)            strL    strR    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the first string is lexically less than the second string.  Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n\"\"   &lt; \"\"    // False\n\"12\" &lt; \"12\"  // False\n\"12\" &lt; \"1\"   // False\n\"1\"  &lt; \"12\"  // True\n\"12\" &lt; \"13\"  // True\n\"13\" &lt; \"12\"  // False\n</code></pre>"},{"location":"the-stdenv-module/stdstring/#less-than-or-equal-to","title":"Less than or equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&lt;=) infix 4 :: {#Char} {#Char} -&gt; Bool\n(&lt;=)            strL    strR    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the first string is lexically less than or equal to the second string. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n\"\"   &lt;= \"\"    // True\n\"12\" &lt;= \"12\"  // True\n\"12\" &lt;= \"1\"   // False\n\"1\"  &lt;= \"12\"  // True\n\"12\" &lt;= \"13\"  // True\n\"13\" &lt;= \"12\"  // False\n</code></pre>"},{"location":"the-stdenv-module/stdstring/#greater-than","title":"Greater than","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&gt;) infix 4 :: {#Char} {#Char} -&gt; Bool\n(&gt;)            strL    strR    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the first string is lexically greater than the second string. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n\"\"   &gt; \"\"    // False\n\"12\" &gt; \"12\"  // False\n\"12\" &gt; \"1\"   // True\n\"1\"  &gt; \"12\"  // False\n\"12\" &gt; \"13\"  // False\n\"13\" &gt; \"12\"  // True\n</code></pre>"},{"location":"the-stdenv-module/stdstring/#greater-than-or-equal-to","title":"Greater than or equal to","text":"<p>Signature</p> <pre><code>// CLEAN\n\n(&gt;=) infix 4 :: {#Char} {#Char} -&gt; Bool\n(&gt;=)            strL    strR    =&gt; ...\n</code></pre> <p>Behavior</p> <p>Returns true if the first string is lexically greater than or equal to the second string. Otherwise, returns false.</p> <p>Usage</p> <pre><code>// CLEAN\n\n\"\"   &gt;= \"\"    // True\n\"12\" &gt;= \"12\"  // True\n\"12\" &gt;= \"1\"   // True\n\"1\"  &gt;= \"12\"  // False\n\"12\" &gt;= \"13\"  // False\n\"13\" &gt;= \"12\"  // True\n</code></pre>"},{"location":"the-stdenv-module/stdtuple/","title":"StdTuple","text":"<p>This module can be imported directly or as a part of the <code>StdEnv</code> module. It provides definitions for relational operations on tuples.</p> <p>However, due to the way that tuples are implemented in CLEAN, an ordered pair is a completely different data structure when compared to an ordered triple.</p> <p>Visit StdTuple on Cloogle for source code of this module.</p>"},{"location":"the-stdenv-module/stdtuple/#relational-operations","title":"Relational operations","text":""},{"location":"the-stdenv-module/stdtuple/#equal-to","title":"Equal to","text":"<p>Signature</p> <p>For ordered pairs </p> <pre><code>// CLEAN\n\n(==) infix 4 :: (T, K)   (T, K)   -&gt; Bool | (Eq T) &amp; (Eq K)\n(==)            (x1, y1) (x2, y2) =&gt; ...\n</code></pre> <p>For ordered triples</p> <pre><code>// CLEAN\n\n(==) infix 4 :: (T, K, V)    (T, K, V)    -&gt; Bool | (== T) &amp; (== K)\n(==)            (x1, y1, z1) (x2, y2, z2) =&gt; ...\n</code></pre> <p>The types <code>T</code> and <code>K</code> must be instances of the class <code>Equality</code> class from the <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Returns true if the given tuples are pairwise equal. Otherwise, returns false.</p> <p>For ordered pairs,</p> <pre><code>// CLEAN\n\n(x1 == y1) &amp;&amp; (x2 == y2)\n</code></pre> <p>For ordered triples,</p> <pre><code>// CLEAN\n\n(x1 == x2) &amp;&amp; (y1 == y2) &amp;&amp; (z1 == z2) \n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\n(1, 'a') == (1, 'a')  // True\n(1, 'a') == (1, 'b')  // False\n(1, 'a') == (1, 'b')  // False\n(2, 'a') == (1, 'a')  // False\n</code></pre>"},{"location":"the-stdenv-module/stdtuple/#not-equal-to","title":"Not equal to","text":"<p>Signature</p> <p>For ordered pairs </p> <pre><code>// CLEAN\n\n(&lt;&gt;) infix 4 :: (T, K)   (T, K)   -&gt; Bool | (Eq T) &amp; (Eq K)\n(&lt;&gt;)            (x1, y1) (x2, y2) =&gt; ...\n</code></pre> <p>For ordered triples</p> <pre><code>// CLEAN\n\n(==) infix 4 :: (T, K, V)    (T, K, V)    -&gt; Bool | (== T) &amp; (== K)\n(==)            (x1, y1, z1) (x2, y2, z2) =&gt; ...\n</code></pre> <p>The types <code>T</code> and <code>K</code> must be instances of the class <code>Equality</code> class from the <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Returns true if the given tuples are not pairwise equal. Otherwise, returns false.</p> <p>For ordered pairs</p> <pre><code>// CLEAN\n\n(x1 &lt;&gt; y1) &amp;&amp; (x2 &lt;&gt; y2)\n</code></pre> <p>For ordered triples</p> <pre><code>// CLEAN\n\n(x1 &lt;&gt; x2) &amp;&amp; (y1 &lt;&gt; y2) &amp;&amp; (z1 &lt;&gt; z2) \n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\n(1, 'a') &lt;&gt; (1, 'a')  // False\n(1, 'a') &lt;&gt; (1, 'b')  // True\n(1, 'a') &lt;&gt; (1, 'b')  // True\n(2, 'a') &lt;&gt; (1, 'a')  // True\n</code></pre>"},{"location":"the-stdenv-module/stdtuple/#less-than","title":"Less than","text":"<p>Signature</p> <p>For ordered pairs </p> <pre><code>// CLEAN\n\n(&lt;) infix 4 :: (T, K)   (T, K)   -&gt; Bool |  (&lt; T) &amp; (&lt; K)\n(&lt;)            (x1, y1) (x2, y2) =&gt; ...\n</code></pre> <p>For ordered triples</p> <pre><code>// CLEAN\n\n(&lt;) infix 4 :: (T, K, V)    (T, K, V)    -&gt; Bool | (&lt; T) &amp; (&lt; K)\n(&lt;)            (x1, y1, z1) (x2, y2, z2) =&gt; ...\n</code></pre> <p>The types <code>T</code> and <code>K</code> must be instances of the class <code>Less than</code> class from the <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Returns true if the first tuple is pairwise less than the second tuple. Otherwise, returns false.</p> <p>For ordered pairs</p> <pre><code>// CLEAN\n\n(x1 &lt; y1) &amp;&amp; (x2 &lt; y2)\n</code></pre> <p>For ordered triples</p> <pre><code>// CLEAN\n\n(x1 &lt; x2) &amp;&amp; (y1 &lt; y2) &amp;&amp; (z1 &lt; z2) \n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\n(1, 'a') &lt; (1, 'a')  // False\n(1, 'a') &lt; (1, 'b')  // False\n(1, 'a') &lt; (1, 'b')  // False\n(2, 'a') &lt; (1, 'a')  // False\n</code></pre>"},{"location":"the-stdenv-module/stdtuple/#less-than-or-equal-to","title":"Less than or equal to","text":"<p>Signature</p> <p>For ordered pairs </p> <pre><code>// CLEAN\n\n(&lt;=) infix 4 :: (T, K)   (T, K)   -&gt; Bool |  (&lt; T) &amp; (&lt; K)\n(&lt;=)            (x1, y1) (x2, y2) =&gt; ...\n</code></pre> <p>For ordered triples</p> <pre><code>// CLEAN\n\n(&lt;=) infix 4 :: (T, K, V)    (T, K, V)    -&gt; Bool | (&lt; T) &amp; (&lt; K)\n(&lt;=)            (x1, y1, z1) (x2, y2, z2) =&gt; ...\n</code></pre> <p>The types <code>T</code> and <code>K</code> must be instances of the class <code>Less than</code> class from the <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Returns true if the first tuple is pairwise less than or equal to the second tuple. Otherwise, returns false.</p> <p>For ordered pairs</p> <pre><code>// CLEAN\n\n(x1 &lt;= y1) &amp;&amp; (x2 &lt;= y2)\n</code></pre> <p>For ordered triples</p> <pre><code>// CLEAN\n\n(x1 &lt;= x2) &amp;&amp; (y1 &lt;= y2) &amp;&amp; (z1 &lt;= z2) \n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\n(1, 'a') &lt;= (1, 'a')  // True\n(1, 'a') &lt;= (1, 'b')  // True\n(1, 'a') &lt;= (1, 'b')  // True\n(2, 'a') &lt;= (1, 'a')  // False\n</code></pre>"},{"location":"the-stdenv-module/stdtuple/#greater-than","title":"Greater than","text":"<p>Signature</p> <p>For ordered pairs </p> <pre><code>// CLEAN\n\n(&gt;) infix 4 :: (T, K)   (T, K)   -&gt; Bool |  (&lt; T) &amp; (&lt; K)\n(&gt;)            (x1, y1) (x2, y2) =&gt; ...\n</code></pre> <p>For ordered triples</p> <pre><code>// CLEAN\n\n(&gt;) infix 4 :: (T, K, V)    (T, K, V)    -&gt; Bool | (&lt; T) &amp; (&lt; K)\n(&gt;)            (x1, y1, z1) (x2, y2, z2) =&gt; ...\n</code></pre> <p>The types <code>T</code> and <code>K</code> must be instances of the class <code>Less than</code> class from the <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Returns true if the first tuple is pairwise greater than the second tuple. Otherwise, returns false.</p> <p>For ordered pairs</p> <pre><code>// CLEAN\n\n(x1 &gt; y1) &amp;&amp; (x2 &gt; y2)\n</code></pre> <p>For ordered triples</p> <pre><code>// CLEAN\n\n(x1 &gt; x2) &amp;&amp; (y1 &gt; y2) &amp;&amp; (z1 &gt; z2) \n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\n(1, 'a') &gt; (1, 'a')  // False\n(1, 'a') &gt; (1, 'b')  // False\n(1, 'a') &gt; (1, 'b')  // False\n(2, 'a') &gt; (1, 'a')  // False\n</code></pre>"},{"location":"the-stdenv-module/stdtuple/#greater-than-or-equal-to","title":"Greater than or equal to","text":"<p>Signature</p> <p>For ordered pairs </p> <pre><code>// CLEAN\n\n(&gt;=) infix 4 :: (T, K)   (T, K)   -&gt; Bool |  (&lt; T) &amp; (&lt; K)\n(&gt;=)            (x1, y1) (x2, y2) =&gt; ...\n</code></pre> <p>For ordered triples</p> <pre><code>// CLEAN\n\n(&gt;=) infix 4 :: (T, K, V)    (T, K, V)    -&gt; Bool | (&lt; T) &amp; (&lt; K)\n(&gt;=)            (x1, y1, z1) (x2, y2, z2) =&gt; ...\n</code></pre> <p>The types <code>T</code> and <code>K</code> must be instances of the class <code>Less than</code> class from the <code>StdOverloaded</code> module.</p> <p>Behavior</p> <p>Returns true if the first tuple is pairwise greater than or equal to the second tuple. Otherwise, returns false.</p> <p>For ordered pairs</p> <pre><code>// CLEAN\n\n(x1 &gt;= y1) &amp;&amp; (x2 &gt;= y2)\n</code></pre> <p>For ordered triples</p> <pre><code>// CLEAN\n\n(x1 &gt;= x2) &amp;&amp; (y1 &gt;= y2) &amp;&amp; (z1 &gt;= z2) \n</code></pre> <p>Usage</p> <pre><code>// CLEAN\n\n(1, 'a') &gt;= (1, 'a')  // True\n(1, 'a') &gt;= (1, 'b')  // False\n(1, 'a') &gt;= (1, 'b')  // False\n(2, 'a') &gt;= (1, 'a')  // True\n</code></pre>"}]}